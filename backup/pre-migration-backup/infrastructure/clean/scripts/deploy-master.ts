#!/usr/bin/env npx ts-node\n\n/**\n * Trinity Master Deployment Script\n * \n * This script provides unified deployment capabilities for Trinity infrastructure,\n * including preparation for CDK resource import operations.\n * \n * Features:\n * - Environment-specific deployments\n * - Pre-deployment validation\n * - Import preparation and execution\n * - Rollback capabilities\n * - Comprehensive logging and monitoring\n */\n\nimport { execSync, spawn } from 'child_process';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { CloudFormationClient, DescribeStacksCommand, ListStackResourcesCommand } from '@aws-sdk/client-cloudformation';\nimport { DynamoDBClient, ListTablesCommand, DescribeTableCommand } from '@aws-sdk/client-dynamodb';\nimport { SSMClient, GetParameterCommand } from '@aws-sdk/client-ssm';\n\ninterface DeploymentConfig {\n  environment: 'dev' | 'staging' | 'production';\n  region: string;\n  stacks: string[];\n  validateBefore: boolean;\n  hotswap: boolean;\n  requireApproval: boolean;\n  importMode: boolean;\n  dryRun: boolean;\n}\n\ninterface StackResource {\n  logicalId: string;\n  physicalId: string;\n  resourceType: string;\n  resourceStatus: string;\n}\n\nclass TrinityDeploymentManager {\n  private config: DeploymentConfig;\n  private cfClient: CloudFormationClient;\n  private dynamoClient: DynamoDBClient;\n  private ssmClient: SSMClient;\n  private deploymentLog: string[] = [];\n\n  constructor(config: DeploymentConfig) {\n    this.config = config;\n    this.cfClient = new CloudFormationClient({ region: config.region });\n    this.dynamoClient = new DynamoDBClient({ region: config.region });\n    this.ssmClient = new SSMClient({ region: config.region });\n    \n    this.log('üöÄ Trinity Deployment Manager initialized');\n    this.log(`üìã Environment: ${config.environment}`);\n    this.log(`üåç Region: ${config.region}`);\n    this.log(`üì¶ Stacks: ${config.stacks.join(', ')}`);\n  }\n\n  private log(message: string, level: 'info' | 'warn' | 'error' = 'info') {\n    const timestamp = new Date().toISOString();\n    const logEntry = `[${timestamp}] ${message}`;\n    \n    this.deploymentLog.push(logEntry);\n    \n    switch (level) {\n      case 'warn':\n        console.warn(`‚ö†Ô∏è ${message}`);\n        break;\n      case 'error':\n        console.error(`‚ùå ${message}`);\n        break;\n      default:\n        console.log(message);\n    }\n  }\n\n  /**\n   * Pre-deployment validation\n   */\n  async validateEnvironment(): Promise<boolean> {\n    this.log('üîç Validating deployment environment...');\n    \n    try {\n      // Check AWS credentials\n      await this.cfClient.send(new DescribeStacksCommand({ MaxItems: 1 }));\n      this.log('‚úÖ AWS credentials valid');\n      \n      // Check CDK CLI availability\n      execSync('cdk --version', { stdio: 'pipe' });\n      this.log('‚úÖ CDK CLI available');\n      \n      // Check Node.js version\n      const nodeVersion = process.version;\n      if (!nodeVersion.startsWith('v18.')) {\n        this.log(`‚ö†Ô∏è Node.js version ${nodeVersion} - recommended: v18.x`, 'warn');\n      } else {\n        this.log(`‚úÖ Node.js version: ${nodeVersion}`);\n      }\n      \n      // Validate CDK app\n      const cdkJson = JSON.parse(fs.readFileSync('cdk.json', 'utf8'));\n      if (!cdkJson.app) {\n        throw new Error('Invalid cdk.json - missing app configuration');\n      }\n      this.log('‚úÖ CDK app configuration valid');\n      \n      // Check for required environment variables\n      const requiredEnvVars = ['AWS_REGION', 'CDK_DEFAULT_REGION'];\n      for (const envVar of requiredEnvVars) {\n        if (!process.env[envVar]) {\n          this.log(`‚ö†Ô∏è Environment variable ${envVar} not set`, 'warn');\n        }\n      }\n      \n      return true;\n      \n    } catch (error) {\n      this.log(`‚ùå Environment validation failed: ${error}`, 'error');\n      return false;\n    }\n  }\n\n  /**\n   * Validate existing AWS resources for import compatibility\n   */\n  async validateImportCompatibility(): Promise<{ compatible: boolean; issues: string[] }> {\n    this.log('üîç Validating import compatibility...');\n    \n    const issues: string[] = [];\n    \n    try {\n      // Check existing DynamoDB tables\n      const tablesResponse = await this.dynamoClient.send(new ListTablesCommand({}));\n      const existingTables = tablesResponse.TableNames || [];\n      \n      const expectedTables = [\n        'trinity-users-dev',\n        'trinity-rooms-dev-v2',\n        'trinity-room-members-dev',\n        'trinity-votes-dev',\n        'trinity-movies-cache-dev',\n        'trinity-room-matches-dev',\n        'trinity-room-invites-dev-v2',\n        'trinity-connections-dev',\n        'trinity-room-movie-cache-dev',\n        'trinity-room-cache-metadata-dev',\n        'trinity-matchmaking-dev',\n        'trinity-filter-cache'\n      ];\n      \n      for (const expectedTable of expectedTables) {\n        if (!existingTables.includes(expectedTable)) {\n          issues.push(`Missing expected table: ${expectedTable}`);\n        } else {\n          // Validate table structure\n          try {\n            const tableDesc = await this.dynamoClient.send(\n              new DescribeTableCommand({ TableName: expectedTable })\n            );\n            \n            if (tableDesc.Table?.TableStatus !== 'ACTIVE') {\n              issues.push(`Table ${expectedTable} is not in ACTIVE state`);\n            }\n            \n            this.log(`‚úÖ Table ${expectedTable} validated`);\n          } catch (error) {\n            issues.push(`Failed to describe table ${expectedTable}: ${error}`);\n          }\n        }\n      }\n      \n      // Check for unexpected tables that might conflict\n      const unexpectedTables = existingTables.filter(table => \n        table.startsWith('trinity-') && !expectedTables.includes(table)\n      );\n      \n      if (unexpectedTables.length > 0) {\n        this.log(`‚ö†Ô∏è Found unexpected Trinity tables: ${unexpectedTables.join(', ')}`, 'warn');\n      }\n      \n      return { compatible: issues.length === 0, issues };\n      \n    } catch (error) {\n      issues.push(`Import compatibility check failed: ${error}`);\n      return { compatible: false, issues };\n    }\n  }\n\n  /**\n   * Generate CDK import configuration\n   */\n  async generateImportConfig(): Promise<void> {\n    this.log('üìù Generating CDK import configuration...');\n    \n    const importConfig = {\n      Resources: {} as Record<string, any>\n    };\n    \n    try {\n      // Get existing DynamoDB tables for import mapping\n      const tablesResponse = await this.dynamoClient.send(new ListTablesCommand({}));\n      const existingTables = tablesResponse.TableNames || [];\n      \n      const trinityTables = existingTables.filter(table => table.startsWith('trinity-'));\n      \n      for (const tableName of trinityTables) {\n        const tableDesc = await this.dynamoClient.send(\n          new DescribeTableCommand({ TableName: tableName })\n        );\n        \n        if (tableDesc.Table) {\n          // Map table name to CDK logical ID\n          const logicalId = this.tableNameToLogicalId(tableName);\n          \n          importConfig.Resources[logicalId] = {\n            Type: 'AWS::DynamoDB::Table',\n            Properties: {\n              TableName: tableName,\n              // Add other properties as needed for import\n            }\n          };\n        }\n      }\n      \n      // Write import configuration\n      const importConfigPath = path.join('cdk-import-config.json');\n      fs.writeFileSync(importConfigPath, JSON.stringify(importConfig, null, 2));\n      \n      this.log(`‚úÖ Import configuration generated: ${importConfigPath}`);\n      \n    } catch (error) {\n      this.log(`‚ùå Failed to generate import config: ${error}`, 'error');\n      throw error;\n    }\n  }\n\n  /**\n   * Convert table name to CDK logical ID\n   */\n  private tableNameToLogicalId(tableName: string): string {\n    return tableName\n      .split('-')\n      .map(part => part.charAt(0).toUpperCase() + part.slice(1))\n      .join('') + 'Table';\n  }\n\n  /**\n   * Execute CDK deployment\n   */\n  async deploy(): Promise<boolean> {\n    this.log('üöÄ Starting CDK deployment...');\n    \n    try {\n      // Build the project first\n      this.log('üî® Building CDK project...');\n      execSync('npm run build', { stdio: 'inherit' });\n      \n      // Prepare deployment command\n      const deployCommand = ['cdk', 'deploy'];\n      \n      if (this.config.stacks.length > 0) {\n        deployCommand.push(...this.config.stacks);\n      } else {\n        deployCommand.push('--all');\n      }\n      \n      if (this.config.hotswap) {\n        deployCommand.push('--hotswap');\n        this.log('‚ö° Hotswap mode enabled');\n      }\n      \n      if (!this.config.requireApproval) {\n        deployCommand.push('--require-approval', 'never');\n      }\n      \n      if (this.config.dryRun) {\n        deployCommand.push('--no-execute');\n        this.log('üîç Dry run mode - no actual deployment');\n      }\n      \n      // Add outputs file\n      deployCommand.push('--outputs-file', 'cdk-outputs.json');\n      \n      this.log(`üìù Executing: ${deployCommand.join(' ')}`);\n      \n      // Execute deployment\n      const deployProcess = spawn(deployCommand[0], deployCommand.slice(1), {\n        stdio: 'inherit',\n        env: { ...process.env, CDK_DEFAULT_REGION: this.config.region }\n      });\n      \n      return new Promise((resolve, reject) => {\n        deployProcess.on('close', (code) => {\n          if (code === 0) {\n            this.log('‚úÖ CDK deployment completed successfully');\n            resolve(true);\n          } else {\n            this.log(`‚ùå CDK deployment failed with code ${code}`, 'error');\n            resolve(false);\n          }\n        });\n        \n        deployProcess.on('error', (error) => {\n          this.log(`‚ùå CDK deployment error: ${error}`, 'error');\n          reject(error);\n        });\n      });\n      \n    } catch (error) {\n      this.log(`‚ùå Deployment failed: ${error}`, 'error');\n      return false;\n    }\n  }\n\n  /**\n   * Execute CDK import operation\n   */\n  async executeImport(stackName: string): Promise<boolean> {\n    this.log(`üì• Starting CDK import for stack: ${stackName}`);\n    \n    try {\n      // Validate import configuration exists\n      const importConfigPath = path.join('cdk-import-config.json');\n      if (!fs.existsSync(importConfigPath)) {\n        await this.generateImportConfig();\n      }\n      \n      // Build the project\n      execSync('npm run build', { stdio: 'inherit' });\n      \n      // Execute import\n      const importCommand = [\n        'cdk', 'import', stackName,\n        '--resource-mapping', importConfigPath\n      ];\n      \n      this.log(`üìù Executing: ${importCommand.join(' ')}`);\n      \n      const importProcess = spawn(importCommand[0], importCommand.slice(1), {\n        stdio: 'inherit',\n        env: { ...process.env, CDK_DEFAULT_REGION: this.config.region }\n      });\n      \n      return new Promise((resolve, reject) => {\n        importProcess.on('close', (code) => {\n          if (code === 0) {\n            this.log(`‚úÖ CDK import completed successfully for ${stackName}`);\n            resolve(true);\n          } else {\n            this.log(`‚ùå CDK import failed for ${stackName} with code ${code}`, 'error');\n            resolve(false);\n          }\n        });\n        \n        importProcess.on('error', (error) => {\n          this.log(`‚ùå CDK import error: ${error}`, 'error');\n          reject(error);\n        });\n      });\n      \n    } catch (error) {\n      this.log(`‚ùå Import failed: ${error}`, 'error');\n      return false;\n    }\n  }\n\n  /**\n   * Setup rollback capability\n   */\n  async setupRollback(): Promise<void> {\n    this.log('üîÑ Setting up rollback capability...');\n    \n    try {\n      // Create backup of current state\n      const backupDir = path.join('deployment-backups', new Date().toISOString().split('T')[0]);\n      if (!fs.existsSync(backupDir)) {\n        fs.mkdirSync(backupDir, { recursive: true });\n      }\n      \n      // Backup CDK outputs\n      if (fs.existsSync('cdk-outputs.json')) {\n        fs.copyFileSync('cdk-outputs.json', path.join(backupDir, 'cdk-outputs-backup.json'));\n      }\n      \n      // Backup deployment log\n      fs.writeFileSync(\n        path.join(backupDir, 'deployment-log.txt'),\n        this.deploymentLog.join('\\n')\n      );\n      \n      this.log(`‚úÖ Rollback backup created: ${backupDir}`);\n      \n    } catch (error) {\n      this.log(`‚ö†Ô∏è Failed to setup rollback: ${error}`, 'warn');\n    }\n  }\n\n  /**\n   * Post-deployment validation\n   */\n  async validateDeployment(): Promise<boolean> {\n    this.log('üîç Validating deployment...');\n    \n    try {\n      // Check if CDK outputs were generated\n      if (!fs.existsSync('cdk-outputs.json')) {\n        this.log('‚ö†Ô∏è CDK outputs file not found', 'warn');\n        return false;\n      }\n      \n      const outputs = JSON.parse(fs.readFileSync('cdk-outputs.json', 'utf8'));\n      this.log(`‚úÖ CDK outputs generated with ${Object.keys(outputs).length} stacks`);\n      \n      // Validate key outputs exist\n      const requiredOutputs = ['GraphQLAPIEndpoint', 'UserPoolId', 'UserPoolClientId'];\n      let hasRequiredOutputs = false;\n      \n      for (const stackOutputs of Object.values(outputs)) {\n        const stackOutputKeys = Object.keys(stackOutputs as object);\n        if (requiredOutputs.some(required => stackOutputKeys.includes(required))) {\n          hasRequiredOutputs = true;\n          break;\n        }\n      }\n      \n      if (!hasRequiredOutputs) {\n        this.log('‚ö†Ô∏è Required outputs not found in deployment', 'warn');\n      } else {\n        this.log('‚úÖ Required outputs validated');\n      }\n      \n      return true;\n      \n    } catch (error) {\n      this.log(`‚ùå Deployment validation failed: ${error}`, 'error');\n      return false;\n    }\n  }\n\n  /**\n   * Generate deployment report\n   */\n  generateReport(): void {\n    this.log('üìä Generating deployment report...');\n    \n    const report = {\n      timestamp: new Date().toISOString(),\n      environment: this.config.environment,\n      region: this.config.region,\n      stacks: this.config.stacks,\n      configuration: this.config,\n      deploymentLog: this.deploymentLog,\n      summary: {\n        totalSteps: this.deploymentLog.length,\n        errors: this.deploymentLog.filter(log => log.includes('‚ùå')).length,\n        warnings: this.deploymentLog.filter(log => log.includes('‚ö†Ô∏è')).length,\n        success: this.deploymentLog.filter(log => log.includes('‚úÖ')).length,\n      }\n    };\n    \n    const reportPath = path.join('deployment-reports', `deployment-${Date.now()}.json`);\n    \n    if (!fs.existsSync('deployment-reports')) {\n      fs.mkdirSync('deployment-reports', { recursive: true });\n    }\n    \n    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));\n    \n    this.log(`üìã Deployment report saved: ${reportPath}`);\n    \n    // Print summary\n    console.log('\\nüìä Deployment Summary:');\n    console.log(`   ‚úÖ Success: ${report.summary.success}`);\n    console.log(`   ‚ö†Ô∏è Warnings: ${report.summary.warnings}`);\n    console.log(`   ‚ùå Errors: ${report.summary.errors}`);\n    console.log(`   üìù Total Steps: ${report.summary.totalSteps}`);\n  }\n\n  /**\n   * Main deployment orchestration\n   */\n  async execute(): Promise<boolean> {\n    try {\n      this.log('üöÄ Starting Trinity deployment orchestration...');\n      \n      // Setup rollback capability\n      await this.setupRollback();\n      \n      // Pre-deployment validation\n      if (this.config.validateBefore) {\n        const isValid = await this.validateEnvironment();\n        if (!isValid) {\n          this.log('‚ùå Pre-deployment validation failed', 'error');\n          return false;\n        }\n      }\n      \n      // Import mode specific validations\n      if (this.config.importMode) {\n        const compatibility = await this.validateImportCompatibility();\n        if (!compatibility.compatible) {\n          this.log('‚ùå Import compatibility check failed:', 'error');\n          compatibility.issues.forEach(issue => this.log(`   - ${issue}`, 'error'));\n          return false;\n        }\n        \n        await this.generateImportConfig();\n      }\n      \n      // Execute deployment or import\n      let success: boolean;\n      if (this.config.importMode) {\n        // Import mode - process each stack individually\n        success = true;\n        for (const stack of this.config.stacks) {\n          const importSuccess = await this.executeImport(stack);\n          if (!importSuccess) {\n            success = false;\n            break;\n          }\n        }\n      } else {\n        // Normal deployment\n        success = await this.deploy();\n      }\n      \n      // Post-deployment validation\n      if (success && !this.config.dryRun) {\n        const validationSuccess = await this.validateDeployment();\n        if (!validationSuccess) {\n          this.log('‚ö†Ô∏è Post-deployment validation had issues', 'warn');\n        }\n      }\n      \n      // Generate report\n      this.generateReport();\n      \n      if (success) {\n        this.log('üéâ Deployment orchestration completed successfully!');\n      } else {\n        this.log('‚ùå Deployment orchestration failed', 'error');\n      }\n      \n      return success;\n      \n    } catch (error) {\n      this.log(`‚ùå Deployment orchestration error: ${error}`, 'error');\n      this.generateReport();\n      return false;\n    }\n  }\n}\n\n// CLI interface\nif (require.main === module) {\n  const args = process.argv.slice(2);\n  \n  const config: DeploymentConfig = {\n    environment: (args.find(arg => arg.startsWith('--env='))?.split('=')[1] as any) || 'dev',\n    region: args.find(arg => arg.startsWith('--region='))?.split('=')[1] || 'eu-west-1',\n    stacks: args.filter(arg => !arg.startsWith('--') && arg !== 'import'),\n    validateBefore: !args.includes('--no-validate'),\n    hotswap: args.includes('--hotswap'),\n    requireApproval: !args.includes('--no-approval'),\n    importMode: args.includes('import'),\n    dryRun: args.includes('--dry-run'),\n  };\n  \n  if (args.includes('--help') || args.includes('-h')) {\n    console.log(`\nTrinity Master Deployment Script\n\nUsage:\n  npx ts-node deploy-master.ts [options] [stack-names...]\n  npx ts-node deploy-master.ts import [options] [stack-names...]\n\nOptions:\n  --env=<env>          Environment (dev|staging|production) [default: dev]\n  --region=<region>    AWS region [default: eu-west-1]\n  --hotswap           Enable CDK hotswap for faster deployments\n  --no-approval       Skip deployment approval prompts\n  --no-validate       Skip pre-deployment validation\n  --dry-run           Show what would be deployed without executing\n  --help, -h          Show this help message\n\nExamples:\n  # Deploy all stacks\n  npx ts-node deploy-master.ts\n  \n  # Deploy specific stacks\n  npx ts-node deploy-master.ts TrinityDatabaseStack TrinityLambdaStack\n  \n  # Import existing resources\n  npx ts-node deploy-master.ts import TrinityDatabaseStack\n  \n  # Production deployment with validation\n  npx ts-node deploy-master.ts --env=production --region=eu-west-1\n  \n  # Fast development deployment\n  npx ts-node deploy-master.ts --hotswap --no-approval TrinityLambdaStack\n`);\n    process.exit(0);\n  }\n  \n  const manager = new TrinityDeploymentManager(config);\n  manager.execute().then(success => {\n    process.exit(success ? 0 : 1);\n  }).catch(error => {\n    console.error('‚ùå Deployment failed:', error);\n    process.exit(1);\n  });\n}\n\nexport { TrinityDeploymentManager, DeploymentConfig };\n"