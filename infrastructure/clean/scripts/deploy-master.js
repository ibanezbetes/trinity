#!/usr/bin/env npx ts-node\n\n/**\n * Trinity Master Deployment Script\n * \n * This script provides unified deployment capabilities for Trinity infrastructure,\n * including preparation for CDK resource import operations.\n * \n * Features:\n * - Environment-specific deployments\n * - Pre-deployment validation\n * - Import preparation and execution\n * - Rollback capabilities\n * - Comprehensive logging and monitoring\n */\n\nimport { execSync, spawn } from 'child_process';\nimport * as fs from 'fs';\nimport * as path from 'path';\nimport { CloudFormationClient, DescribeStacksCommand, ListStackResourcesCommand } from '@aws-sdk/client-cloudformation';\nimport { DynamoDBClient, ListTablesCommand, DescribeTableCommand } from '@aws-sdk/client-dynamodb';\nimport { SSMClient, GetParameterCommand } from '@aws-sdk/client-ssm';\n\ninterface DeploymentConfig {\n  environment: 'dev' | 'staging' | 'production';\n  region: string;\n  stacks: string[];\n  validateBefore: boolean;\n  hotswap: boolean;\n  requireApproval: boolean;\n  importMode: boolean;\n  dryRun: boolean;\n}\n\ninterface StackResource {\n  logicalId: string;\n  physicalId: string;\n  resourceType: string;\n  resourceStatus: string;\n}\n\nclass TrinityDeploymentManager {\n  private config: DeploymentConfig;\n  private cfClient: CloudFormationClient;\n  private dynamoClient: DynamoDBClient;\n  private ssmClient: SSMClient;\n  private deploymentLog: string[] = [];\n\n  constructor(config: DeploymentConfig) {\n    this.config = config;\n    this.cfClient = new CloudFormationClient({ region: config.region });\n    this.dynamoClient = new DynamoDBClient({ region: config.region });\n    this.ssmClient = new SSMClient({ region: config.region });\n    \n    this.log('üöÄ Trinity Deployment Manager initialized');\n    this.log(`üìã Environment: ${config.environment}`);\n    this.log(`üåç Region: ${config.region}`);\n    this.log(`üì¶ Stacks: ${config.stacks.join(', ')}`);\n  }\n\n  private log(message: string, level: 'info' | 'warn' | 'error' = 'info') {\n    const timestamp = new Date().toISOString();\n    const logEntry = `[${timestamp}] ${message}`;\n    \n    this.deploymentLog.push(logEntry);\n    \n    switch (level) {\n      case 'warn':\n        console.warn(`‚ö†Ô∏è ${message}`);\n        break;\n      case 'error':\n        console.error(`‚ùå ${message}`);\n        break;\n      default:\n        console.log(message);\n    }\n  }\n\n  /**\n   * Pre-deployment validation\n   */\n  async validateEnvironment(): Promise<boolean> {\n    this.log('üîç Validating deployment environment...');\n    \n    try {\n      // Check AWS credentials\n      await this.cfClient.send(new DescribeStacksCommand({ MaxItems: 1 }));\n      this.log('‚úÖ AWS credentials valid');\n      \n      // Check CDK CLI availability\n      execSync('cdk --version', { stdio: 'pipe' });\n      this.log('‚úÖ CDK CLI available');\n      \n      // Check Node.js version\n      const nodeVersion = process.version;\n      if (!nodeVersion.startsWith('v18.')) {\n        this.log(`‚ö†Ô∏è Node.js version ${nodeVersion} - recommended: v18.x`, 'warn');\n      } else {\n        this.log(`‚úÖ Node.js version: ${nodeVersion}`);\n      }\n      \n      // Validate CDK app\n      const cdkJson = JSON.parse(fs.readFileSync('cdk.json', 'utf8'));\n      if (!cdkJson.app) {\n        throw new Error('Invalid cdk.json - missing app configuration');\n      }\n      this.log('‚úÖ CDK app configuration valid');\n      \n      // Check for required environment variables\n      const requiredEnvVars = ['AWS_REGION', 'CDK_DEFAULT_REGION'];\n      for (const envVar of requiredEnvVars) {\n        if (!process.env[envVar]) {\n          this.log(`‚ö†Ô∏è Environment variable ${envVar} not set`, 'warn');\n        }\n      }\n      \n      return true;\n      \n    } catch (error) {\n      this.log(`‚ùå Environment validation failed: ${error}`, 'error');\n      return false;\n    }\n  }\n\n  /**\n   * Validate existing AWS resources for import compatibility\n   */\n  async validateImportCompatibility(): Promise<{ compatible: boolean; issues: string[] }> {\n    this.log('üîç Validating import compatibility...');\n    \n    const issues: string[] = [];\n    \n    try {\n      // Check existing DynamoDB tables\n      const tablesResponse = await this.dynamoClient.send(new ListTablesCommand({}));\n      const existingTables = tablesResponse.TableNames || [];\n      \n      const expectedTables = [\n        'trinity-users-dev',\n        'trinity-rooms-dev-v2',\n        'trinity-room-members-dev',\n        'trinity-votes-dev',\n        'trinity-movies-cache-dev',\n        'trinity-room-matches-dev',\n        'trinity-room-invites-dev-v2',\n        'trinity-connections-dev',\n        'trinity-room-movie-cache-dev',\n        'trinity-room-cache-metadata-dev',\n        'trinity-matchmaking-dev',\n        'trinity-filter-cache'\n      ];\n      \n      for (const expectedTable of expectedTables) {\n        if (!existingTables.includes(expectedTable)) {\n          issues.push(`Missing expected table: ${expectedTable}`);\n        } else {\n          // Validate table structure\n          try {\n            const tableDesc = await this.dynamoClient.send(\n              new DescribeTableCommand({ TableName: expectedTable })\n            );\n            \n            if (tableDesc.Table?.TableStatus !== 'ACTIVE') {\n              issues.push(`Table ${expectedTable} is not in ACTIVE state`);\n            }\n            \n            this.log(`‚úÖ Table ${expectedTable} validated`);\n          } catch (error) {\n            issues.push(`Failed to describe table ${expectedTable}: ${error}`);\n          }\n        }\n      }\n      \n      // Check for unexpected tables that might conflict\n      const unexpectedTables = existingTables.filter(table => \n        table.startsWith('trinity-') && !expectedTables.includes(table)\n      );\n      \n      if (unexpectedTables.length > 0) {\n        this.log(`‚ö†Ô∏è Found unexpected Trinity tables: ${unexpectedTables.join(', ')}`, 'warn');\n      }\n      \n      return { compatible: issues.length === 0, issues };\n      \n    } catch (error) {\n      issues.push(`Import compatibility check failed: ${error}`);\n      return { compatible: false, issues };\n    }\n  }\n\n  /**\n   * Generate CDK import configuration\n   */\n  async generateImportConfig(): Promise<void> {\n    this.log('üìù Generating CDK import configuration...');\n    \n    const importConfig = {\n      Resources: {} as Record<string, any>\n    };\n    \n    try {\n      // Get existing DynamoDB tables for import mapping\n      const tablesResponse = await this.dynamoClient.send(new ListTablesCommand({}));\n      const existingTables = tablesResponse.TableNames || [];\n      \n      const trinityTables = existingTables.filter(table => table.startsWith('trinity-'));\n      \n      for (const tableName of trinityTables) {\n        const tableDesc = await this.dynamoClient.send(\n          new DescribeTableCommand({ TableName: tableName })\n        );\n        \n        if (tableDesc.Table) {\n          // Map table name to CDK logical ID\n          const logicalId = this.tableNameToLogicalId(tableName);\n          \n          importConfig.Resources[logicalId] = {\n            Type: 'AWS::DynamoDB::Table',\n            Properties: {\n              TableName: tableName,\n              // Add other properties as needed for import\n            }\n          };\n        }\n      }\n      \n      // Write import configuration\n      const importConfigPath = path.join('cdk-import-config.json');\n      fs.writeFileSync(importConfigPath, JSON.stringify(importConfig, null, 2));\n      \n      this.log(`‚úÖ Import configuration generated: ${importConfigPath}`);\n      \n    } catch (error) {\n      this.log(`‚ùå Failed to generate import config: ${error}`, 'error');\n      throw error;\n    }\n  }\n\n  /**\n   * Convert table name to CDK logical ID\n   */\n  private tableNameToLogicalId(tableName: string): string {\n    return tableName\n      .split('-')\n      .map(part => part.charAt(0).toUpperCase() + part.slice(1))\n      .join('') + 'Table';\n  }\n\n  /**\n   * Execute CDK deployment\n   */\n  async deploy(): Promise<boolean> {\n    this.log('üöÄ Starting CDK deployment...');\n    \n    try {\n      // Build the project first\n      this.log('üî® Building CDK project...');\n      execSync('npm run build', { stdio: 'inherit' });\n      \n      // Prepare deployment command\n      const deployCommand = ['cdk', 'deploy'];\n      \n      if (this.config.stacks.length > 0) {\n        deployCommand.push(...this.config.stacks);\n      } else {\n        deployCommand.push('--all');\n      }\n      \n      if (this.config.hotswap) {\n        deployCommand.push('--hotswap');\n        this.log('‚ö° Hotswap mode enabled');\n      }\n      \n      if (!this.config.requireApproval) {\n        deployCommand.push('--require-approval', 'never');\n      }\n      \n      if (this.config.dryRun) {\n        deployCommand.push('--no-execute');\n        this.log('üîç Dry run mode - no actual deployment');\n      }\n      \n      // Add outputs file\n      deployCommand.push('--outputs-file', 'cdk-outputs.json');\n      \n      this.log(`üìù Executing: ${deployCommand.join(' ')}`);\n      \n      // Execute deployment\n      const deployProcess = spawn(deployCommand[0], deployCommand.slice(1), {\n        stdio: 'inherit',\n        env: { ...process.env, CDK_DEFAULT_REGION: this.config.region }\n      });\n      \n      return new Promise((resolve, reject) => {\n        deployProcess.on('close', (code) => {\n          if (code === 0) {\n            this.log('‚úÖ CDK deployment completed successfully');\n            resolve(true);\n          } else {\n            this.log(`‚ùå CDK deployment failed with code ${code}`, 'error');\n            resolve(false);\n          }\n        });\n        \n        deployProcess.on('error', (error) => {\n          this.log(`‚ùå CDK deployment error: ${error}`, 'error');\n          reject(error);\n        });\n      });\n      \n    } catch (error) {\n      this.log(`‚ùå Deployment failed: ${error}`, 'error');\n      return false;\n    }\n  }\n\n  /**\n   * Execute CDK import operation\n   */\n  async executeImport(stackName: string): Promise<boolean> {\n    this.log(`üì• Starting CDK import for stack: ${stackName}`);\n    \n    try {\n      // Validate import configuration exists\n      const importConfigPath = path.join('cdk-import-config.json');\n      if (!fs.existsSync(importConfigPath)) {\n        await this.generateImportConfig();\n      }\n      \n      // Build the project\n      execSync('npm run build', { stdio: 'inherit' });\n      \n      // Execute import\n      const importCommand = [\n        'cdk', 'import', stackName,\n        '--resource-mapping', importConfigPath\n      ];\n      \n      this.log(`üìù Executing: ${importCommand.join(' ')}`);\n      \n      const importProcess = spawn(importCommand[0], importCommand.slice(1), {\n        stdio: 'inherit',\n        env: { ...process.env, CDK_DEFAULT_REGION: this.config.region }\n      });\n      \n      return new Promise((resolve, reject) => {\n        importProcess.on('close', (code) => {\n          if (code === 0) {\n            this.log(`‚úÖ CDK import completed successfully for ${stackName}`);\n            resolve(true);\n          } else {\n            this.log(`‚ùå CDK import failed for ${stackName} with code ${code}`, 'error');\n            resolve(false);\n          }\n        });\n        \n        importProcess.on('error', (error) => {\n          this.log(`‚ùå CDK import error: ${error}`, 'error');\n          reject(error);\n        });\n      });\n      \n    } catch (error) {\n      this.log(`‚ùå Import failed: ${error}`, 'error');\n      return false;\n    }\n  }\n\n  /**\n   * Setup rollback capability\n   */\n  async setupRollback(): Promise<void> {\n    this.log('üîÑ Setting up rollback capability...');\n    \n    try {\n      // Create backup of current state\n      const backupDir = path.join('deployment-backups', new Date().toISOString().split('T')[0]);\n      if (!fs.existsSync(backupDir)) {\n        fs.mkdirSync(backupDir, { recursive: true });\n      }\n      \n      // Backup CDK outputs\n      if (fs.existsSync('cdk-outputs.json')) {\n        fs.copyFileSync('cdk-outputs.json', path.join(backupDir, 'cdk-outputs-backup.json'));\n      }\n      \n      // Backup deployment log\n      fs.writeFileSync(\n        path.join(backupDir, 'deployment-log.txt'),\n        this.deploymentLog.join('\\n')\n      );\n      \n      this.log(`‚úÖ Rollback backup created: ${backupDir}`);\n      \n    } catch (error) {\n      this.log(`‚ö†Ô∏è Failed to setup rollback: ${error}`, 'warn');\n    }\n  }\n\n  /**\n   * Post-deployment validation\n   */\n  async validateDeployment(): Promise<boolean> {\n    this.log('üîç Validating deployment...');\n    \n    try {\n      // Check if CDK outputs were generated\n      if (!fs.existsSync('cdk-outputs.json')) {\n        this.log('‚ö†Ô∏è CDK outputs file not found', 'warn');\n        return false;\n      }\n      \n      const outputs = JSON.parse(fs.readFileSync('cdk-outputs.json', 'utf8'));\n      this.log(`‚úÖ CDK outputs generated with ${Object.keys(outputs).length} stacks`);\n      \n      // Validate key outputs exist\n      const requiredOutputs = ['GraphQLAPIEndpoint', 'UserPoolId', 'UserPoolClientId'];\n      let hasRequiredOutputs = false;\n      \n      for (const stackOutputs of Object.values(outputs)) {\n        const stackOutputKeys = Object.keys(stackOutputs as object);\n        if (requiredOutputs.some(required => stackOutputKeys.includes(required))) {\n          hasRequiredOutputs = true;\n          break;\n        }\n      }\n      \n      if (!hasRequiredOutputs) {\n        this.log('‚ö†Ô∏è Required outputs not found in deployment', 'warn');\n      } else {\n        this.log('‚úÖ Required outputs validated');\n      }\n      \n      return true;\n      \n    } catch (error) {\n      this.log(`‚ùå Deployment validation failed: ${error}`, 'error');\n      return false;\n    }\n  }\n\n  /**\n   * Generate deployment report\n   */\n  generateReport(): void {\n    this.log('üìä Generating deployment report...');\n    \n    const report = {\n      timestamp: new Date().toISOString(),\n      environment: this.config.environment,\n      region: this.config.region,\n      stacks: this.config.stacks,\n      configuration: this.config,\n      deploymentLog: this.deploymentLog,\n      summary: {\n        totalSteps: this.deploymentLog.length,\n        errors: this.deploymentLog.filter(log => log.includes('‚ùå')).length,\n        warnings: this.deploymentLog.filter(log => log.includes('‚ö†Ô∏è')).length,\n        success: this.deploymentLog.filter(log => log.includes('‚úÖ')).length,\n      }\n    };\n    \n    const reportPath = path.join('deployment-reports', `deployment-${Date.now()}.json`);\n    \n    if (!fs.existsSync('deployment-reports')) {\n      fs.mkdirSync('deployment-reports', { recursive: true });\n    }\n    \n    fs.writeFileSync(reportPath, JSON.stringify(report, null, 2));\n    \n    this.log(`üìã Deployment report saved: ${reportPath}`);\n    \n    // Print summary\n    console.log('\\nüìä Deployment Summary:');\n    console.log(`   ‚úÖ Success: ${report.summary.success}`);\n    console.log(`   ‚ö†Ô∏è Warnings: ${report.summary.warnings}`);\n    console.log(`   ‚ùå Errors: ${report.summary.errors}`);\n    console.log(`   üìù Total Steps: ${report.summary.totalSteps}`);\n  }\n\n  /**\n   * Main deployment orchestration\n   */\n  async execute(): Promise<boolean> {\n    try {\n      this.log('üöÄ Starting Trinity deployment orchestration...');\n      \n      // Setup rollback capability\n      await this.setupRollback();\n      \n      // Pre-deployment validation\n      if (this.config.validateBefore) {\n        const isValid = await this.validateEnvironment();\n        if (!isValid) {\n          this.log('‚ùå Pre-deployment validation failed', 'error');\n          return false;\n        }\n      }\n      \n      // Import mode specific validations\n      if (this.config.importMode) {\n        const compatibility = await this.validateImportCompatibility();\n        if (!compatibility.compatible) {\n          this.log('‚ùå Import compatibility check failed:', 'error');\n          compatibility.issues.forEach(issue => this.log(`   - ${issue}`, 'error'));\n          return false;\n        }\n        \n        await this.generateImportConfig();\n      }\n      \n      // Execute deployment or import\n      let success: boolean;\n      if (this.config.importMode) {\n        // Import mode - process each stack individually\n        success = true;\n        for (const stack of this.config.stacks) {\n          const importSuccess = await this.executeImport(stack);\n          if (!importSuccess) {\n            success = false;\n            break;\n          }\n        }\n      } else {\n        // Normal deployment\n        success = await this.deploy();\n      }\n      \n      // Post-deployment validation\n      if (success && !this.config.dryRun) {\n        const validationSuccess = await this.validateDeployment();\n        if (!validationSuccess) {\n          this.log('‚ö†Ô∏è Post-deployment validation had issues', 'warn');\n        }\n      }\n      \n      // Generate report\n      this.generateReport();\n      \n      if (success) {\n        this.log('üéâ Deployment orchestration completed successfully!');\n      } else {\n        this.log('‚ùå Deployment orchestration failed', 'error');\n      }\n      \n      return success;\n      \n    } catch (error) {\n      this.log(`‚ùå Deployment orchestration error: ${error}`, 'error');\n      this.generateReport();\n      return false;\n    }\n  }\n}\n\n// CLI interface\nif (require.main === module) {\n  const args = process.argv.slice(2);\n  \n  const config: DeploymentConfig = {\n    environment: (args.find(arg => arg.startsWith('--env='))?.split('=')[1] as any) || 'dev',\n    region: args.find(arg => arg.startsWith('--region='))?.split('=')[1] || 'eu-west-1',\n    stacks: args.filter(arg => !arg.startsWith('--') && arg !== 'import'),\n    validateBefore: !args.includes('--no-validate'),\n    hotswap: args.includes('--hotswap'),\n    requireApproval: !args.includes('--no-approval'),\n    importMode: args.includes('import'),\n    dryRun: args.includes('--dry-run'),\n  };\n  \n  if (args.includes('--help') || args.includes('-h')) {\n    console.log(`\nTrinity Master Deployment Script\n\nUsage:\n  npx ts-node deploy-master.ts [options] [stack-names...]\n  npx ts-node deploy-master.ts import [options] [stack-names...]\n\nOptions:\n  --env=<env>          Environment (dev|staging|production) [default: dev]\n  --region=<region>    AWS region [default: eu-west-1]\n  --hotswap           Enable CDK hotswap for faster deployments\n  --no-approval       Skip deployment approval prompts\n  --no-validate       Skip pre-deployment validation\n  --dry-run           Show what would be deployed without executing\n  --help, -h          Show this help message\n\nExamples:\n  # Deploy all stacks\n  npx ts-node deploy-master.ts\n  \n  # Deploy specific stacks\n  npx ts-node deploy-master.ts TrinityDatabaseStack TrinityLambdaStack\n  \n  # Import existing resources\n  npx ts-node deploy-master.ts import TrinityDatabaseStack\n  \n  # Production deployment with validation\n  npx ts-node deploy-master.ts --env=production --region=eu-west-1\n  \n  # Fast development deployment\n  npx ts-node deploy-master.ts --hotswap --no-approval TrinityLambdaStack\n`);\n    process.exit(0);\n  }\n  \n  const manager = new TrinityDeploymentManager(config);\n  manager.execute().then(success => {\n    process.exit(success ? 0 : 1);\n  }).catch(error => {\n    console.error('‚ùå Deployment failed:', error);\n    process.exit(1);\n  });\n}\n\nexport { TrinityDeploymentManager, DeploymentConfig };\n"
"use strict";
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGVwbG95LW1hc3Rlci5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbImRlcGxveS1tYXN0ZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsInNvdXJjZXNDb250ZW50IjpbIiMhL3Vzci9iaW4vZW52IG5weCB0cy1ub2RlXFxuXFxuLyoqXFxuICogVHJpbml0eSBNYXN0ZXIgRGVwbG95bWVudCBTY3JpcHRcXG4gKiBcXG4gKiBUaGlzIHNjcmlwdCBwcm92aWRlcyB1bmlmaWVkIGRlcGxveW1lbnQgY2FwYWJpbGl0aWVzIGZvciBUcmluaXR5IGluZnJhc3RydWN0dXJlLFxcbiAqIGluY2x1ZGluZyBwcmVwYXJhdGlvbiBmb3IgQ0RLIHJlc291cmNlIGltcG9ydCBvcGVyYXRpb25zLlxcbiAqIFxcbiAqIEZlYXR1cmVzOlxcbiAqIC0gRW52aXJvbm1lbnQtc3BlY2lmaWMgZGVwbG95bWVudHNcXG4gKiAtIFByZS1kZXBsb3ltZW50IHZhbGlkYXRpb25cXG4gKiAtIEltcG9ydCBwcmVwYXJhdGlvbiBhbmQgZXhlY3V0aW9uXFxuICogLSBSb2xsYmFjayBjYXBhYmlsaXRpZXNcXG4gKiAtIENvbXByZWhlbnNpdmUgbG9nZ2luZyBhbmQgbW9uaXRvcmluZ1xcbiAqL1xcblxcbmltcG9ydCB7IGV4ZWNTeW5jLCBzcGF3biB9IGZyb20gJ2NoaWxkX3Byb2Nlc3MnO1xcbmltcG9ydCAqIGFzIGZzIGZyb20gJ2ZzJztcXG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gJ3BhdGgnO1xcbmltcG9ydCB7IENsb3VkRm9ybWF0aW9uQ2xpZW50LCBEZXNjcmliZVN0YWNrc0NvbW1hbmQsIExpc3RTdGFja1Jlc291cmNlc0NvbW1hbmQgfSBmcm9tICdAYXdzLXNkay9jbGllbnQtY2xvdWRmb3JtYXRpb24nO1xcbmltcG9ydCB7IER5bmFtb0RCQ2xpZW50LCBMaXN0VGFibGVzQ29tbWFuZCwgRGVzY3JpYmVUYWJsZUNvbW1hbmQgfSBmcm9tICdAYXdzLXNkay9jbGllbnQtZHluYW1vZGInO1xcbmltcG9ydCB7IFNTTUNsaWVudCwgR2V0UGFyYW1ldGVyQ29tbWFuZCB9IGZyb20gJ0Bhd3Mtc2RrL2NsaWVudC1zc20nO1xcblxcbmludGVyZmFjZSBEZXBsb3ltZW50Q29uZmlnIHtcXG4gIGVudmlyb25tZW50OiAnZGV2JyB8ICdzdGFnaW5nJyB8ICdwcm9kdWN0aW9uJztcXG4gIHJlZ2lvbjogc3RyaW5nO1xcbiAgc3RhY2tzOiBzdHJpbmdbXTtcXG4gIHZhbGlkYXRlQmVmb3JlOiBib29sZWFuO1xcbiAgaG90c3dhcDogYm9vbGVhbjtcXG4gIHJlcXVpcmVBcHByb3ZhbDogYm9vbGVhbjtcXG4gIGltcG9ydE1vZGU6IGJvb2xlYW47XFxuICBkcnlSdW46IGJvb2xlYW47XFxufVxcblxcbmludGVyZmFjZSBTdGFja1Jlc291cmNlIHtcXG4gIGxvZ2ljYWxJZDogc3RyaW5nO1xcbiAgcGh5c2ljYWxJZDogc3RyaW5nO1xcbiAgcmVzb3VyY2VUeXBlOiBzdHJpbmc7XFxuICByZXNvdXJjZVN0YXR1czogc3RyaW5nO1xcbn1cXG5cXG5jbGFzcyBUcmluaXR5RGVwbG95bWVudE1hbmFnZXIge1xcbiAgcHJpdmF0ZSBjb25maWc6IERlcGxveW1lbnRDb25maWc7XFxuICBwcml2YXRlIGNmQ2xpZW50OiBDbG91ZEZvcm1hdGlvbkNsaWVudDtcXG4gIHByaXZhdGUgZHluYW1vQ2xpZW50OiBEeW5hbW9EQkNsaWVudDtcXG4gIHByaXZhdGUgc3NtQ2xpZW50OiBTU01DbGllbnQ7XFxuICBwcml2YXRlIGRlcGxveW1lbnRMb2c6IHN0cmluZ1tdID0gW107XFxuXFxuICBjb25zdHJ1Y3Rvcihjb25maWc6IERlcGxveW1lbnRDb25maWcpIHtcXG4gICAgdGhpcy5jb25maWcgPSBjb25maWc7XFxuICAgIHRoaXMuY2ZDbGllbnQgPSBuZXcgQ2xvdWRGb3JtYXRpb25DbGllbnQoeyByZWdpb246IGNvbmZpZy5yZWdpb24gfSk7XFxuICAgIHRoaXMuZHluYW1vQ2xpZW50ID0gbmV3IER5bmFtb0RCQ2xpZW50KHsgcmVnaW9uOiBjb25maWcucmVnaW9uIH0pO1xcbiAgICB0aGlzLnNzbUNsaWVudCA9IG5ldyBTU01DbGllbnQoeyByZWdpb246IGNvbmZpZy5yZWdpb24gfSk7XFxuICAgIFxcbiAgICB0aGlzLmxvZygn8J+agCBUcmluaXR5IERlcGxveW1lbnQgTWFuYWdlciBpbml0aWFsaXplZCcpO1xcbiAgICB0aGlzLmxvZyhg8J+TiyBFbnZpcm9ubWVudDogJHtjb25maWcuZW52aXJvbm1lbnR9YCk7XFxuICAgIHRoaXMubG9nKGDwn4yNIFJlZ2lvbjogJHtjb25maWcucmVnaW9ufWApO1xcbiAgICB0aGlzLmxvZyhg8J+TpiBTdGFja3M6ICR7Y29uZmlnLnN0YWNrcy5qb2luKCcsICcpfWApO1xcbiAgfVxcblxcbiAgcHJpdmF0ZSBsb2cobWVzc2FnZTogc3RyaW5nLCBsZXZlbDogJ2luZm8nIHwgJ3dhcm4nIHwgJ2Vycm9yJyA9ICdpbmZvJykge1xcbiAgICBjb25zdCB0aW1lc3RhbXAgPSBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCk7XFxuICAgIGNvbnN0IGxvZ0VudHJ5ID0gYFske3RpbWVzdGFtcH1dICR7bWVzc2FnZX1gO1xcbiAgICBcXG4gICAgdGhpcy5kZXBsb3ltZW50TG9nLnB1c2gobG9nRW50cnkpO1xcbiAgICBcXG4gICAgc3dpdGNoIChsZXZlbCkge1xcbiAgICAgIGNhc2UgJ3dhcm4nOlxcbiAgICAgICAgY29uc29sZS53YXJuKGDimqDvuI8gJHttZXNzYWdlfWApO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAnZXJyb3InOlxcbiAgICAgICAgY29uc29sZS5lcnJvcihg4p2MICR7bWVzc2FnZX1gKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGRlZmF1bHQ6XFxuICAgICAgICBjb25zb2xlLmxvZyhtZXNzYWdlKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBQcmUtZGVwbG95bWVudCB2YWxpZGF0aW9uXFxuICAgKi9cXG4gIGFzeW5jIHZhbGlkYXRlRW52aXJvbm1lbnQoKTogUHJvbWlzZTxib29sZWFuPiB7XFxuICAgIHRoaXMubG9nKCfwn5SNIFZhbGlkYXRpbmcgZGVwbG95bWVudCBlbnZpcm9ubWVudC4uLicpO1xcbiAgICBcXG4gICAgdHJ5IHtcXG4gICAgICAvLyBDaGVjayBBV1MgY3JlZGVudGlhbHNcXG4gICAgICBhd2FpdCB0aGlzLmNmQ2xpZW50LnNlbmQobmV3IERlc2NyaWJlU3RhY2tzQ29tbWFuZCh7IE1heEl0ZW1zOiAxIH0pKTtcXG4gICAgICB0aGlzLmxvZygn4pyFIEFXUyBjcmVkZW50aWFscyB2YWxpZCcpO1xcbiAgICAgIFxcbiAgICAgIC8vIENoZWNrIENESyBDTEkgYXZhaWxhYmlsaXR5XFxuICAgICAgZXhlY1N5bmMoJ2NkayAtLXZlcnNpb24nLCB7IHN0ZGlvOiAncGlwZScgfSk7XFxuICAgICAgdGhpcy5sb2coJ+KchSBDREsgQ0xJIGF2YWlsYWJsZScpO1xcbiAgICAgIFxcbiAgICAgIC8vIENoZWNrIE5vZGUuanMgdmVyc2lvblxcbiAgICAgIGNvbnN0IG5vZGVWZXJzaW9uID0gcHJvY2Vzcy52ZXJzaW9uO1xcbiAgICAgIGlmICghbm9kZVZlcnNpb24uc3RhcnRzV2l0aCgndjE4LicpKSB7XFxuICAgICAgICB0aGlzLmxvZyhg4pqg77iPIE5vZGUuanMgdmVyc2lvbiAke25vZGVWZXJzaW9ufSAtIHJlY29tbWVuZGVkOiB2MTgueGAsICd3YXJuJyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMubG9nKGDinIUgTm9kZS5qcyB2ZXJzaW9uOiAke25vZGVWZXJzaW9ufWApO1xcbiAgICAgIH1cXG4gICAgICBcXG4gICAgICAvLyBWYWxpZGF0ZSBDREsgYXBwXFxuICAgICAgY29uc3QgY2RrSnNvbiA9IEpTT04ucGFyc2UoZnMucmVhZEZpbGVTeW5jKCdjZGsuanNvbicsICd1dGY4JykpO1xcbiAgICAgIGlmICghY2RrSnNvbi5hcHApIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjZGsuanNvbiAtIG1pc3NpbmcgYXBwIGNvbmZpZ3VyYXRpb24nKTtcXG4gICAgICB9XFxuICAgICAgdGhpcy5sb2coJ+KchSBDREsgYXBwIGNvbmZpZ3VyYXRpb24gdmFsaWQnKTtcXG4gICAgICBcXG4gICAgICAvLyBDaGVjayBmb3IgcmVxdWlyZWQgZW52aXJvbm1lbnQgdmFyaWFibGVzXFxuICAgICAgY29uc3QgcmVxdWlyZWRFbnZWYXJzID0gWydBV1NfUkVHSU9OJywgJ0NES19ERUZBVUxUX1JFR0lPTiddO1xcbiAgICAgIGZvciAoY29uc3QgZW52VmFyIG9mIHJlcXVpcmVkRW52VmFycykge1xcbiAgICAgICAgaWYgKCFwcm9jZXNzLmVudltlbnZWYXJdKSB7XFxuICAgICAgICAgIHRoaXMubG9nKGDimqDvuI8gRW52aXJvbm1lbnQgdmFyaWFibGUgJHtlbnZWYXJ9IG5vdCBzZXRgLCAnd2FybicpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICBcXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcXG4gICAgICB0aGlzLmxvZyhg4p2MIEVudmlyb25tZW50IHZhbGlkYXRpb24gZmFpbGVkOiAke2Vycm9yfWAsICdlcnJvcicpO1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBWYWxpZGF0ZSBleGlzdGluZyBBV1MgcmVzb3VyY2VzIGZvciBpbXBvcnQgY29tcGF0aWJpbGl0eVxcbiAgICovXFxuICBhc3luYyB2YWxpZGF0ZUltcG9ydENvbXBhdGliaWxpdHkoKTogUHJvbWlzZTx7IGNvbXBhdGlibGU6IGJvb2xlYW47IGlzc3Vlczogc3RyaW5nW10gfT4ge1xcbiAgICB0aGlzLmxvZygn8J+UjSBWYWxpZGF0aW5nIGltcG9ydCBjb21wYXRpYmlsaXR5Li4uJyk7XFxuICAgIFxcbiAgICBjb25zdCBpc3N1ZXM6IHN0cmluZ1tdID0gW107XFxuICAgIFxcbiAgICB0cnkge1xcbiAgICAgIC8vIENoZWNrIGV4aXN0aW5nIER5bmFtb0RCIHRhYmxlc1xcbiAgICAgIGNvbnN0IHRhYmxlc1Jlc3BvbnNlID0gYXdhaXQgdGhpcy5keW5hbW9DbGllbnQuc2VuZChuZXcgTGlzdFRhYmxlc0NvbW1hbmQoe30pKTtcXG4gICAgICBjb25zdCBleGlzdGluZ1RhYmxlcyA9IHRhYmxlc1Jlc3BvbnNlLlRhYmxlTmFtZXMgfHwgW107XFxuICAgICAgXFxuICAgICAgY29uc3QgZXhwZWN0ZWRUYWJsZXMgPSBbXFxuICAgICAgICAndHJpbml0eS11c2Vycy1kZXYnLFxcbiAgICAgICAgJ3RyaW5pdHktcm9vbXMtZGV2LXYyJyxcXG4gICAgICAgICd0cmluaXR5LXJvb20tbWVtYmVycy1kZXYnLFxcbiAgICAgICAgJ3RyaW5pdHktdm90ZXMtZGV2JyxcXG4gICAgICAgICd0cmluaXR5LW1vdmllcy1jYWNoZS1kZXYnLFxcbiAgICAgICAgJ3RyaW5pdHktcm9vbS1tYXRjaGVzLWRldicsXFxuICAgICAgICAndHJpbml0eS1yb29tLWludml0ZXMtZGV2LXYyJyxcXG4gICAgICAgICd0cmluaXR5LWNvbm5lY3Rpb25zLWRldicsXFxuICAgICAgICAndHJpbml0eS1yb29tLW1vdmllLWNhY2hlLWRldicsXFxuICAgICAgICAndHJpbml0eS1yb29tLWNhY2hlLW1ldGFkYXRhLWRldicsXFxuICAgICAgICAndHJpbml0eS1tYXRjaG1ha2luZy1kZXYnLFxcbiAgICAgICAgJ3RyaW5pdHktZmlsdGVyLWNhY2hlJ1xcbiAgICAgIF07XFxuICAgICAgXFxuICAgICAgZm9yIChjb25zdCBleHBlY3RlZFRhYmxlIG9mIGV4cGVjdGVkVGFibGVzKSB7XFxuICAgICAgICBpZiAoIWV4aXN0aW5nVGFibGVzLmluY2x1ZGVzKGV4cGVjdGVkVGFibGUpKSB7XFxuICAgICAgICAgIGlzc3Vlcy5wdXNoKGBNaXNzaW5nIGV4cGVjdGVkIHRhYmxlOiAke2V4cGVjdGVkVGFibGV9YCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAvLyBWYWxpZGF0ZSB0YWJsZSBzdHJ1Y3R1cmVcXG4gICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBjb25zdCB0YWJsZURlc2MgPSBhd2FpdCB0aGlzLmR5bmFtb0NsaWVudC5zZW5kKFxcbiAgICAgICAgICAgICAgbmV3IERlc2NyaWJlVGFibGVDb21tYW5kKHsgVGFibGVOYW1lOiBleHBlY3RlZFRhYmxlIH0pXFxuICAgICAgICAgICAgKTtcXG4gICAgICAgICAgICBcXG4gICAgICAgICAgICBpZiAodGFibGVEZXNjLlRhYmxlPy5UYWJsZVN0YXR1cyAhPT0gJ0FDVElWRScpIHtcXG4gICAgICAgICAgICAgIGlzc3Vlcy5wdXNoKGBUYWJsZSAke2V4cGVjdGVkVGFibGV9IGlzIG5vdCBpbiBBQ1RJVkUgc3RhdGVgKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgXFxuICAgICAgICAgICAgdGhpcy5sb2coYOKchSBUYWJsZSAke2V4cGVjdGVkVGFibGV9IHZhbGlkYXRlZGApO1xcbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xcbiAgICAgICAgICAgIGlzc3Vlcy5wdXNoKGBGYWlsZWQgdG8gZGVzY3JpYmUgdGFibGUgJHtleHBlY3RlZFRhYmxlfTogJHtlcnJvcn1gKTtcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBcXG4gICAgICAvLyBDaGVjayBmb3IgdW5leHBlY3RlZCB0YWJsZXMgdGhhdCBtaWdodCBjb25mbGljdFxcbiAgICAgIGNvbnN0IHVuZXhwZWN0ZWRUYWJsZXMgPSBleGlzdGluZ1RhYmxlcy5maWx0ZXIodGFibGUgPT4gXFxuICAgICAgICB0YWJsZS5zdGFydHNXaXRoKCd0cmluaXR5LScpICYmICFleHBlY3RlZFRhYmxlcy5pbmNsdWRlcyh0YWJsZSlcXG4gICAgICApO1xcbiAgICAgIFxcbiAgICAgIGlmICh1bmV4cGVjdGVkVGFibGVzLmxlbmd0aCA+IDApIHtcXG4gICAgICAgIHRoaXMubG9nKGDimqDvuI8gRm91bmQgdW5leHBlY3RlZCBUcmluaXR5IHRhYmxlczogJHt1bmV4cGVjdGVkVGFibGVzLmpvaW4oJywgJyl9YCwgJ3dhcm4nKTtcXG4gICAgICB9XFxuICAgICAgXFxuICAgICAgcmV0dXJuIHsgY29tcGF0aWJsZTogaXNzdWVzLmxlbmd0aCA9PT0gMCwgaXNzdWVzIH07XFxuICAgICAgXFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgICAgaXNzdWVzLnB1c2goYEltcG9ydCBjb21wYXRpYmlsaXR5IGNoZWNrIGZhaWxlZDogJHtlcnJvcn1gKTtcXG4gICAgICByZXR1cm4geyBjb21wYXRpYmxlOiBmYWxzZSwgaXNzdWVzIH07XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8qKlxcbiAgICogR2VuZXJhdGUgQ0RLIGltcG9ydCBjb25maWd1cmF0aW9uXFxuICAgKi9cXG4gIGFzeW5jIGdlbmVyYXRlSW1wb3J0Q29uZmlnKCk6IFByb21pc2U8dm9pZD4ge1xcbiAgICB0aGlzLmxvZygn8J+TnSBHZW5lcmF0aW5nIENESyBpbXBvcnQgY29uZmlndXJhdGlvbi4uLicpO1xcbiAgICBcXG4gICAgY29uc3QgaW1wb3J0Q29uZmlnID0ge1xcbiAgICAgIFJlc291cmNlczoge30gYXMgUmVjb3JkPHN0cmluZywgYW55PlxcbiAgICB9O1xcbiAgICBcXG4gICAgdHJ5IHtcXG4gICAgICAvLyBHZXQgZXhpc3RpbmcgRHluYW1vREIgdGFibGVzIGZvciBpbXBvcnQgbWFwcGluZ1xcbiAgICAgIGNvbnN0IHRhYmxlc1Jlc3BvbnNlID0gYXdhaXQgdGhpcy5keW5hbW9DbGllbnQuc2VuZChuZXcgTGlzdFRhYmxlc0NvbW1hbmQoe30pKTtcXG4gICAgICBjb25zdCBleGlzdGluZ1RhYmxlcyA9IHRhYmxlc1Jlc3BvbnNlLlRhYmxlTmFtZXMgfHwgW107XFxuICAgICAgXFxuICAgICAgY29uc3QgdHJpbml0eVRhYmxlcyA9IGV4aXN0aW5nVGFibGVzLmZpbHRlcih0YWJsZSA9PiB0YWJsZS5zdGFydHNXaXRoKCd0cmluaXR5LScpKTtcXG4gICAgICBcXG4gICAgICBmb3IgKGNvbnN0IHRhYmxlTmFtZSBvZiB0cmluaXR5VGFibGVzKSB7XFxuICAgICAgICBjb25zdCB0YWJsZURlc2MgPSBhd2FpdCB0aGlzLmR5bmFtb0NsaWVudC5zZW5kKFxcbiAgICAgICAgICBuZXcgRGVzY3JpYmVUYWJsZUNvbW1hbmQoeyBUYWJsZU5hbWU6IHRhYmxlTmFtZSB9KVxcbiAgICAgICAgKTtcXG4gICAgICAgIFxcbiAgICAgICAgaWYgKHRhYmxlRGVzYy5UYWJsZSkge1xcbiAgICAgICAgICAvLyBNYXAgdGFibGUgbmFtZSB0byBDREsgbG9naWNhbCBJRFxcbiAgICAgICAgICBjb25zdCBsb2dpY2FsSWQgPSB0aGlzLnRhYmxlTmFtZVRvTG9naWNhbElkKHRhYmxlTmFtZSk7XFxuICAgICAgICAgIFxcbiAgICAgICAgICBpbXBvcnRDb25maWcuUmVzb3VyY2VzW2xvZ2ljYWxJZF0gPSB7XFxuICAgICAgICAgICAgVHlwZTogJ0FXUzo6RHluYW1vREI6OlRhYmxlJyxcXG4gICAgICAgICAgICBQcm9wZXJ0aWVzOiB7XFxuICAgICAgICAgICAgICBUYWJsZU5hbWU6IHRhYmxlTmFtZSxcXG4gICAgICAgICAgICAgIC8vIEFkZCBvdGhlciBwcm9wZXJ0aWVzIGFzIG5lZWRlZCBmb3IgaW1wb3J0XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9O1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBcXG4gICAgICAvLyBXcml0ZSBpbXBvcnQgY29uZmlndXJhdGlvblxcbiAgICAgIGNvbnN0IGltcG9ydENvbmZpZ1BhdGggPSBwYXRoLmpvaW4oJ2Nkay1pbXBvcnQtY29uZmlnLmpzb24nKTtcXG4gICAgICBmcy53cml0ZUZpbGVTeW5jKGltcG9ydENvbmZpZ1BhdGgsIEpTT04uc3RyaW5naWZ5KGltcG9ydENvbmZpZywgbnVsbCwgMikpO1xcbiAgICAgIFxcbiAgICAgIHRoaXMubG9nKGDinIUgSW1wb3J0IGNvbmZpZ3VyYXRpb24gZ2VuZXJhdGVkOiAke2ltcG9ydENvbmZpZ1BhdGh9YCk7XFxuICAgICAgXFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgICAgdGhpcy5sb2coYOKdjCBGYWlsZWQgdG8gZ2VuZXJhdGUgaW1wb3J0IGNvbmZpZzogJHtlcnJvcn1gLCAnZXJyb3InKTtcXG4gICAgICB0aHJvdyBlcnJvcjtcXG4gICAgfVxcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBDb252ZXJ0IHRhYmxlIG5hbWUgdG8gQ0RLIGxvZ2ljYWwgSURcXG4gICAqL1xcbiAgcHJpdmF0ZSB0YWJsZU5hbWVUb0xvZ2ljYWxJZCh0YWJsZU5hbWU6IHN0cmluZyk6IHN0cmluZyB7XFxuICAgIHJldHVybiB0YWJsZU5hbWVcXG4gICAgICAuc3BsaXQoJy0nKVxcbiAgICAgIC5tYXAocGFydCA9PiBwYXJ0LmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpICsgcGFydC5zbGljZSgxKSlcXG4gICAgICAuam9pbignJykgKyAnVGFibGUnO1xcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBFeGVjdXRlIENESyBkZXBsb3ltZW50XFxuICAgKi9cXG4gIGFzeW5jIGRlcGxveSgpOiBQcm9taXNlPGJvb2xlYW4+IHtcXG4gICAgdGhpcy5sb2coJ/CfmoAgU3RhcnRpbmcgQ0RLIGRlcGxveW1lbnQuLi4nKTtcXG4gICAgXFxuICAgIHRyeSB7XFxuICAgICAgLy8gQnVpbGQgdGhlIHByb2plY3QgZmlyc3RcXG4gICAgICB0aGlzLmxvZygn8J+UqCBCdWlsZGluZyBDREsgcHJvamVjdC4uLicpO1xcbiAgICAgIGV4ZWNTeW5jKCducG0gcnVuIGJ1aWxkJywgeyBzdGRpbzogJ2luaGVyaXQnIH0pO1xcbiAgICAgIFxcbiAgICAgIC8vIFByZXBhcmUgZGVwbG95bWVudCBjb21tYW5kXFxuICAgICAgY29uc3QgZGVwbG95Q29tbWFuZCA9IFsnY2RrJywgJ2RlcGxveSddO1xcbiAgICAgIFxcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5zdGFja3MubGVuZ3RoID4gMCkge1xcbiAgICAgICAgZGVwbG95Q29tbWFuZC5wdXNoKC4uLnRoaXMuY29uZmlnLnN0YWNrcyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGRlcGxveUNvbW1hbmQucHVzaCgnLS1hbGwnKTtcXG4gICAgICB9XFxuICAgICAgXFxuICAgICAgaWYgKHRoaXMuY29uZmlnLmhvdHN3YXApIHtcXG4gICAgICAgIGRlcGxveUNvbW1hbmQucHVzaCgnLS1ob3Rzd2FwJyk7XFxuICAgICAgICB0aGlzLmxvZygn4pqhIEhvdHN3YXAgbW9kZSBlbmFibGVkJyk7XFxuICAgICAgfVxcbiAgICAgIFxcbiAgICAgIGlmICghdGhpcy5jb25maWcucmVxdWlyZUFwcHJvdmFsKSB7XFxuICAgICAgICBkZXBsb3lDb21tYW5kLnB1c2goJy0tcmVxdWlyZS1hcHByb3ZhbCcsICduZXZlcicpO1xcbiAgICAgIH1cXG4gICAgICBcXG4gICAgICBpZiAodGhpcy5jb25maWcuZHJ5UnVuKSB7XFxuICAgICAgICBkZXBsb3lDb21tYW5kLnB1c2goJy0tbm8tZXhlY3V0ZScpO1xcbiAgICAgICAgdGhpcy5sb2coJ/CflI0gRHJ5IHJ1biBtb2RlIC0gbm8gYWN0dWFsIGRlcGxveW1lbnQnKTtcXG4gICAgICB9XFxuICAgICAgXFxuICAgICAgLy8gQWRkIG91dHB1dHMgZmlsZVxcbiAgICAgIGRlcGxveUNvbW1hbmQucHVzaCgnLS1vdXRwdXRzLWZpbGUnLCAnY2RrLW91dHB1dHMuanNvbicpO1xcbiAgICAgIFxcbiAgICAgIHRoaXMubG9nKGDwn5OdIEV4ZWN1dGluZzogJHtkZXBsb3lDb21tYW5kLmpvaW4oJyAnKX1gKTtcXG4gICAgICBcXG4gICAgICAvLyBFeGVjdXRlIGRlcGxveW1lbnRcXG4gICAgICBjb25zdCBkZXBsb3lQcm9jZXNzID0gc3Bhd24oZGVwbG95Q29tbWFuZFswXSwgZGVwbG95Q29tbWFuZC5zbGljZSgxKSwge1xcbiAgICAgICAgc3RkaW86ICdpbmhlcml0JyxcXG4gICAgICAgIGVudjogeyAuLi5wcm9jZXNzLmVudiwgQ0RLX0RFRkFVTFRfUkVHSU9OOiB0aGlzLmNvbmZpZy5yZWdpb24gfVxcbiAgICAgIH0pO1xcbiAgICAgIFxcbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XFxuICAgICAgICBkZXBsb3lQcm9jZXNzLm9uKCdjbG9zZScsIChjb2RlKSA9PiB7XFxuICAgICAgICAgIGlmIChjb2RlID09PSAwKSB7XFxuICAgICAgICAgICAgdGhpcy5sb2coJ+KchSBDREsgZGVwbG95bWVudCBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5Jyk7XFxuICAgICAgICAgICAgcmVzb2x2ZSh0cnVlKTtcXG4gICAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICB0aGlzLmxvZyhg4p2MIENESyBkZXBsb3ltZW50IGZhaWxlZCB3aXRoIGNvZGUgJHtjb2RlfWAsICdlcnJvcicpO1xcbiAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIFxcbiAgICAgICAgZGVwbG95UHJvY2Vzcy5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcXG4gICAgICAgICAgdGhpcy5sb2coYOKdjCBDREsgZGVwbG95bWVudCBlcnJvcjogJHtlcnJvcn1gLCAnZXJyb3InKTtcXG4gICAgICAgICAgcmVqZWN0KGVycm9yKTtcXG4gICAgICAgIH0pO1xcbiAgICAgIH0pO1xcbiAgICAgIFxcbiAgICB9IGNhdGNoIChlcnJvcikge1xcbiAgICAgIHRoaXMubG9nKGDinYwgRGVwbG95bWVudCBmYWlsZWQ6ICR7ZXJyb3J9YCwgJ2Vycm9yJyk7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICB9XFxuXFxuICAvKipcXG4gICAqIEV4ZWN1dGUgQ0RLIGltcG9ydCBvcGVyYXRpb25cXG4gICAqL1xcbiAgYXN5bmMgZXhlY3V0ZUltcG9ydChzdGFja05hbWU6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4ge1xcbiAgICB0aGlzLmxvZyhg8J+TpSBTdGFydGluZyBDREsgaW1wb3J0IGZvciBzdGFjazogJHtzdGFja05hbWV9YCk7XFxuICAgIFxcbiAgICB0cnkge1xcbiAgICAgIC8vIFZhbGlkYXRlIGltcG9ydCBjb25maWd1cmF0aW9uIGV4aXN0c1xcbiAgICAgIGNvbnN0IGltcG9ydENvbmZpZ1BhdGggPSBwYXRoLmpvaW4oJ2Nkay1pbXBvcnQtY29uZmlnLmpzb24nKTtcXG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoaW1wb3J0Q29uZmlnUGF0aCkpIHtcXG4gICAgICAgIGF3YWl0IHRoaXMuZ2VuZXJhdGVJbXBvcnRDb25maWcoKTtcXG4gICAgICB9XFxuICAgICAgXFxuICAgICAgLy8gQnVpbGQgdGhlIHByb2plY3RcXG4gICAgICBleGVjU3luYygnbnBtIHJ1biBidWlsZCcsIHsgc3RkaW86ICdpbmhlcml0JyB9KTtcXG4gICAgICBcXG4gICAgICAvLyBFeGVjdXRlIGltcG9ydFxcbiAgICAgIGNvbnN0IGltcG9ydENvbW1hbmQgPSBbXFxuICAgICAgICAnY2RrJywgJ2ltcG9ydCcsIHN0YWNrTmFtZSxcXG4gICAgICAgICctLXJlc291cmNlLW1hcHBpbmcnLCBpbXBvcnRDb25maWdQYXRoXFxuICAgICAgXTtcXG4gICAgICBcXG4gICAgICB0aGlzLmxvZyhg8J+TnSBFeGVjdXRpbmc6ICR7aW1wb3J0Q29tbWFuZC5qb2luKCcgJyl9YCk7XFxuICAgICAgXFxuICAgICAgY29uc3QgaW1wb3J0UHJvY2VzcyA9IHNwYXduKGltcG9ydENvbW1hbmRbMF0sIGltcG9ydENvbW1hbmQuc2xpY2UoMSksIHtcXG4gICAgICAgIHN0ZGlvOiAnaW5oZXJpdCcsXFxuICAgICAgICBlbnY6IHsgLi4ucHJvY2Vzcy5lbnYsIENES19ERUZBVUxUX1JFR0lPTjogdGhpcy5jb25maWcucmVnaW9uIH1cXG4gICAgICB9KTtcXG4gICAgICBcXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xcbiAgICAgICAgaW1wb3J0UHJvY2Vzcy5vbignY2xvc2UnLCAoY29kZSkgPT4ge1xcbiAgICAgICAgICBpZiAoY29kZSA9PT0gMCkge1xcbiAgICAgICAgICAgIHRoaXMubG9nKGDinIUgQ0RLIGltcG9ydCBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5IGZvciAke3N0YWNrTmFtZX1gKTtcXG4gICAgICAgICAgICByZXNvbHZlKHRydWUpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHRoaXMubG9nKGDinYwgQ0RLIGltcG9ydCBmYWlsZWQgZm9yICR7c3RhY2tOYW1lfSB3aXRoIGNvZGUgJHtjb2RlfWAsICdlcnJvcicpO1xcbiAgICAgICAgICAgIHJlc29sdmUoZmFsc2UpO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9KTtcXG4gICAgICAgIFxcbiAgICAgICAgaW1wb3J0UHJvY2Vzcy5vbignZXJyb3InLCAoZXJyb3IpID0+IHtcXG4gICAgICAgICAgdGhpcy5sb2coYOKdjCBDREsgaW1wb3J0IGVycm9yOiAke2Vycm9yfWAsICdlcnJvcicpO1xcbiAgICAgICAgICByZWplY3QoZXJyb3IpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfSk7XFxuICAgICAgXFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgICAgdGhpcy5sb2coYOKdjCBJbXBvcnQgZmFpbGVkOiAke2Vycm9yfWAsICdlcnJvcicpO1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBTZXR1cCByb2xsYmFjayBjYXBhYmlsaXR5XFxuICAgKi9cXG4gIGFzeW5jIHNldHVwUm9sbGJhY2soKTogUHJvbWlzZTx2b2lkPiB7XFxuICAgIHRoaXMubG9nKCfwn5SEIFNldHRpbmcgdXAgcm9sbGJhY2sgY2FwYWJpbGl0eS4uLicpO1xcbiAgICBcXG4gICAgdHJ5IHtcXG4gICAgICAvLyBDcmVhdGUgYmFja3VwIG9mIGN1cnJlbnQgc3RhdGVcXG4gICAgICBjb25zdCBiYWNrdXBEaXIgPSBwYXRoLmpvaW4oJ2RlcGxveW1lbnQtYmFja3VwcycsIG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKS5zcGxpdCgnVCcpWzBdKTtcXG4gICAgICBpZiAoIWZzLmV4aXN0c1N5bmMoYmFja3VwRGlyKSkge1xcbiAgICAgICAgZnMubWtkaXJTeW5jKGJhY2t1cERpciwgeyByZWN1cnNpdmU6IHRydWUgfSk7XFxuICAgICAgfVxcbiAgICAgIFxcbiAgICAgIC8vIEJhY2t1cCBDREsgb3V0cHV0c1xcbiAgICAgIGlmIChmcy5leGlzdHNTeW5jKCdjZGstb3V0cHV0cy5qc29uJykpIHtcXG4gICAgICAgIGZzLmNvcHlGaWxlU3luYygnY2RrLW91dHB1dHMuanNvbicsIHBhdGguam9pbihiYWNrdXBEaXIsICdjZGstb3V0cHV0cy1iYWNrdXAuanNvbicpKTtcXG4gICAgICB9XFxuICAgICAgXFxuICAgICAgLy8gQmFja3VwIGRlcGxveW1lbnQgbG9nXFxuICAgICAgZnMud3JpdGVGaWxlU3luYyhcXG4gICAgICAgIHBhdGguam9pbihiYWNrdXBEaXIsICdkZXBsb3ltZW50LWxvZy50eHQnKSxcXG4gICAgICAgIHRoaXMuZGVwbG95bWVudExvZy5qb2luKCdcXFxcbicpXFxuICAgICAgKTtcXG4gICAgICBcXG4gICAgICB0aGlzLmxvZyhg4pyFIFJvbGxiYWNrIGJhY2t1cCBjcmVhdGVkOiAke2JhY2t1cERpcn1gKTtcXG4gICAgICBcXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcXG4gICAgICB0aGlzLmxvZyhg4pqg77iPIEZhaWxlZCB0byBzZXR1cCByb2xsYmFjazogJHtlcnJvcn1gLCAnd2FybicpO1xcbiAgICB9XFxuICB9XFxuXFxuICAvKipcXG4gICAqIFBvc3QtZGVwbG95bWVudCB2YWxpZGF0aW9uXFxuICAgKi9cXG4gIGFzeW5jIHZhbGlkYXRlRGVwbG95bWVudCgpOiBQcm9taXNlPGJvb2xlYW4+IHtcXG4gICAgdGhpcy5sb2coJ/CflI0gVmFsaWRhdGluZyBkZXBsb3ltZW50Li4uJyk7XFxuICAgIFxcbiAgICB0cnkge1xcbiAgICAgIC8vIENoZWNrIGlmIENESyBvdXRwdXRzIHdlcmUgZ2VuZXJhdGVkXFxuICAgICAgaWYgKCFmcy5leGlzdHNTeW5jKCdjZGstb3V0cHV0cy5qc29uJykpIHtcXG4gICAgICAgIHRoaXMubG9nKCfimqDvuI8gQ0RLIG91dHB1dHMgZmlsZSBub3QgZm91bmQnLCAnd2FybicpO1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgIH1cXG4gICAgICBcXG4gICAgICBjb25zdCBvdXRwdXRzID0gSlNPTi5wYXJzZShmcy5yZWFkRmlsZVN5bmMoJ2Nkay1vdXRwdXRzLmpzb24nLCAndXRmOCcpKTtcXG4gICAgICB0aGlzLmxvZyhg4pyFIENESyBvdXRwdXRzIGdlbmVyYXRlZCB3aXRoICR7T2JqZWN0LmtleXMob3V0cHV0cykubGVuZ3RofSBzdGFja3NgKTtcXG4gICAgICBcXG4gICAgICAvLyBWYWxpZGF0ZSBrZXkgb3V0cHV0cyBleGlzdFxcbiAgICAgIGNvbnN0IHJlcXVpcmVkT3V0cHV0cyA9IFsnR3JhcGhRTEFQSUVuZHBvaW50JywgJ1VzZXJQb29sSWQnLCAnVXNlclBvb2xDbGllbnRJZCddO1xcbiAgICAgIGxldCBoYXNSZXF1aXJlZE91dHB1dHMgPSBmYWxzZTtcXG4gICAgICBcXG4gICAgICBmb3IgKGNvbnN0IHN0YWNrT3V0cHV0cyBvZiBPYmplY3QudmFsdWVzKG91dHB1dHMpKSB7XFxuICAgICAgICBjb25zdCBzdGFja091dHB1dEtleXMgPSBPYmplY3Qua2V5cyhzdGFja091dHB1dHMgYXMgb2JqZWN0KTtcXG4gICAgICAgIGlmIChyZXF1aXJlZE91dHB1dHMuc29tZShyZXF1aXJlZCA9PiBzdGFja091dHB1dEtleXMuaW5jbHVkZXMocmVxdWlyZWQpKSkge1xcbiAgICAgICAgICBoYXNSZXF1aXJlZE91dHB1dHMgPSB0cnVlO1xcbiAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgICAgXFxuICAgICAgaWYgKCFoYXNSZXF1aXJlZE91dHB1dHMpIHtcXG4gICAgICAgIHRoaXMubG9nKCfimqDvuI8gUmVxdWlyZWQgb3V0cHV0cyBub3QgZm91bmQgaW4gZGVwbG95bWVudCcsICd3YXJuJyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHRoaXMubG9nKCfinIUgUmVxdWlyZWQgb3V0cHV0cyB2YWxpZGF0ZWQnKTtcXG4gICAgICB9XFxuICAgICAgXFxuICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgXFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgICAgdGhpcy5sb2coYOKdjCBEZXBsb3ltZW50IHZhbGlkYXRpb24gZmFpbGVkOiAke2Vycm9yfWAsICdlcnJvcicpO1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLyoqXFxuICAgKiBHZW5lcmF0ZSBkZXBsb3ltZW50IHJlcG9ydFxcbiAgICovXFxuICBnZW5lcmF0ZVJlcG9ydCgpOiB2b2lkIHtcXG4gICAgdGhpcy5sb2coJ/Cfk4ogR2VuZXJhdGluZyBkZXBsb3ltZW50IHJlcG9ydC4uLicpO1xcbiAgICBcXG4gICAgY29uc3QgcmVwb3J0ID0ge1xcbiAgICAgIHRpbWVzdGFtcDogbmV3IERhdGUoKS50b0lTT1N0cmluZygpLFxcbiAgICAgIGVudmlyb25tZW50OiB0aGlzLmNvbmZpZy5lbnZpcm9ubWVudCxcXG4gICAgICByZWdpb246IHRoaXMuY29uZmlnLnJlZ2lvbixcXG4gICAgICBzdGFja3M6IHRoaXMuY29uZmlnLnN0YWNrcyxcXG4gICAgICBjb25maWd1cmF0aW9uOiB0aGlzLmNvbmZpZyxcXG4gICAgICBkZXBsb3ltZW50TG9nOiB0aGlzLmRlcGxveW1lbnRMb2csXFxuICAgICAgc3VtbWFyeToge1xcbiAgICAgICAgdG90YWxTdGVwczogdGhpcy5kZXBsb3ltZW50TG9nLmxlbmd0aCxcXG4gICAgICAgIGVycm9yczogdGhpcy5kZXBsb3ltZW50TG9nLmZpbHRlcihsb2cgPT4gbG9nLmluY2x1ZGVzKCfinYwnKSkubGVuZ3RoLFxcbiAgICAgICAgd2FybmluZ3M6IHRoaXMuZGVwbG95bWVudExvZy5maWx0ZXIobG9nID0+IGxvZy5pbmNsdWRlcygn4pqg77iPJykpLmxlbmd0aCxcXG4gICAgICAgIHN1Y2Nlc3M6IHRoaXMuZGVwbG95bWVudExvZy5maWx0ZXIobG9nID0+IGxvZy5pbmNsdWRlcygn4pyFJykpLmxlbmd0aCxcXG4gICAgICB9XFxuICAgIH07XFxuICAgIFxcbiAgICBjb25zdCByZXBvcnRQYXRoID0gcGF0aC5qb2luKCdkZXBsb3ltZW50LXJlcG9ydHMnLCBgZGVwbG95bWVudC0ke0RhdGUubm93KCl9Lmpzb25gKTtcXG4gICAgXFxuICAgIGlmICghZnMuZXhpc3RzU3luYygnZGVwbG95bWVudC1yZXBvcnRzJykpIHtcXG4gICAgICBmcy5ta2RpclN5bmMoJ2RlcGxveW1lbnQtcmVwb3J0cycsIHsgcmVjdXJzaXZlOiB0cnVlIH0pO1xcbiAgICB9XFxuICAgIFxcbiAgICBmcy53cml0ZUZpbGVTeW5jKHJlcG9ydFBhdGgsIEpTT04uc3RyaW5naWZ5KHJlcG9ydCwgbnVsbCwgMikpO1xcbiAgICBcXG4gICAgdGhpcy5sb2coYPCfk4sgRGVwbG95bWVudCByZXBvcnQgc2F2ZWQ6ICR7cmVwb3J0UGF0aH1gKTtcXG4gICAgXFxuICAgIC8vIFByaW50IHN1bW1hcnlcXG4gICAgY29uc29sZS5sb2coJ1xcXFxu8J+TiiBEZXBsb3ltZW50IFN1bW1hcnk6Jyk7XFxuICAgIGNvbnNvbGUubG9nKGAgICDinIUgU3VjY2VzczogJHtyZXBvcnQuc3VtbWFyeS5zdWNjZXNzfWApO1xcbiAgICBjb25zb2xlLmxvZyhgICAg4pqg77iPIFdhcm5pbmdzOiAke3JlcG9ydC5zdW1tYXJ5Lndhcm5pbmdzfWApO1xcbiAgICBjb25zb2xlLmxvZyhgICAg4p2MIEVycm9yczogJHtyZXBvcnQuc3VtbWFyeS5lcnJvcnN9YCk7XFxuICAgIGNvbnNvbGUubG9nKGAgICDwn5OdIFRvdGFsIFN0ZXBzOiAke3JlcG9ydC5zdW1tYXJ5LnRvdGFsU3RlcHN9YCk7XFxuICB9XFxuXFxuICAvKipcXG4gICAqIE1haW4gZGVwbG95bWVudCBvcmNoZXN0cmF0aW9uXFxuICAgKi9cXG4gIGFzeW5jIGV4ZWN1dGUoKTogUHJvbWlzZTxib29sZWFuPiB7XFxuICAgIHRyeSB7XFxuICAgICAgdGhpcy5sb2coJ/CfmoAgU3RhcnRpbmcgVHJpbml0eSBkZXBsb3ltZW50IG9yY2hlc3RyYXRpb24uLi4nKTtcXG4gICAgICBcXG4gICAgICAvLyBTZXR1cCByb2xsYmFjayBjYXBhYmlsaXR5XFxuICAgICAgYXdhaXQgdGhpcy5zZXR1cFJvbGxiYWNrKCk7XFxuICAgICAgXFxuICAgICAgLy8gUHJlLWRlcGxveW1lbnQgdmFsaWRhdGlvblxcbiAgICAgIGlmICh0aGlzLmNvbmZpZy52YWxpZGF0ZUJlZm9yZSkge1xcbiAgICAgICAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IHRoaXMudmFsaWRhdGVFbnZpcm9ubWVudCgpO1xcbiAgICAgICAgaWYgKCFpc1ZhbGlkKSB7XFxuICAgICAgICAgIHRoaXMubG9nKCfinYwgUHJlLWRlcGxveW1lbnQgdmFsaWRhdGlvbiBmYWlsZWQnLCAnZXJyb3InKTtcXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBcXG4gICAgICAvLyBJbXBvcnQgbW9kZSBzcGVjaWZpYyB2YWxpZGF0aW9uc1xcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5pbXBvcnRNb2RlKSB7XFxuICAgICAgICBjb25zdCBjb21wYXRpYmlsaXR5ID0gYXdhaXQgdGhpcy52YWxpZGF0ZUltcG9ydENvbXBhdGliaWxpdHkoKTtcXG4gICAgICAgIGlmICghY29tcGF0aWJpbGl0eS5jb21wYXRpYmxlKSB7XFxuICAgICAgICAgIHRoaXMubG9nKCfinYwgSW1wb3J0IGNvbXBhdGliaWxpdHkgY2hlY2sgZmFpbGVkOicsICdlcnJvcicpO1xcbiAgICAgICAgICBjb21wYXRpYmlsaXR5Lmlzc3Vlcy5mb3JFYWNoKGlzc3VlID0+IHRoaXMubG9nKGAgICAtICR7aXNzdWV9YCwgJ2Vycm9yJykpO1xcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgICAgICB9XFxuICAgICAgICBcXG4gICAgICAgIGF3YWl0IHRoaXMuZ2VuZXJhdGVJbXBvcnRDb25maWcoKTtcXG4gICAgICB9XFxuICAgICAgXFxuICAgICAgLy8gRXhlY3V0ZSBkZXBsb3ltZW50IG9yIGltcG9ydFxcbiAgICAgIGxldCBzdWNjZXNzOiBib29sZWFuO1xcbiAgICAgIGlmICh0aGlzLmNvbmZpZy5pbXBvcnRNb2RlKSB7XFxuICAgICAgICAvLyBJbXBvcnQgbW9kZSAtIHByb2Nlc3MgZWFjaCBzdGFjayBpbmRpdmlkdWFsbHlcXG4gICAgICAgIHN1Y2Nlc3MgPSB0cnVlO1xcbiAgICAgICAgZm9yIChjb25zdCBzdGFjayBvZiB0aGlzLmNvbmZpZy5zdGFja3MpIHtcXG4gICAgICAgICAgY29uc3QgaW1wb3J0U3VjY2VzcyA9IGF3YWl0IHRoaXMuZXhlY3V0ZUltcG9ydChzdGFjayk7XFxuICAgICAgICAgIGlmICghaW1wb3J0U3VjY2Vzcykge1xcbiAgICAgICAgICAgIHN1Y2Nlc3MgPSBmYWxzZTtcXG4gICAgICAgICAgICBicmVhaztcXG4gICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICAvLyBOb3JtYWwgZGVwbG95bWVudFxcbiAgICAgICAgc3VjY2VzcyA9IGF3YWl0IHRoaXMuZGVwbG95KCk7XFxuICAgICAgfVxcbiAgICAgIFxcbiAgICAgIC8vIFBvc3QtZGVwbG95bWVudCB2YWxpZGF0aW9uXFxuICAgICAgaWYgKHN1Y2Nlc3MgJiYgIXRoaXMuY29uZmlnLmRyeVJ1bikge1xcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvblN1Y2Nlc3MgPSBhd2FpdCB0aGlzLnZhbGlkYXRlRGVwbG95bWVudCgpO1xcbiAgICAgICAgaWYgKCF2YWxpZGF0aW9uU3VjY2Vzcykge1xcbiAgICAgICAgICB0aGlzLmxvZygn4pqg77iPIFBvc3QtZGVwbG95bWVudCB2YWxpZGF0aW9uIGhhZCBpc3N1ZXMnLCAnd2FybicpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBcXG4gICAgICAvLyBHZW5lcmF0ZSByZXBvcnRcXG4gICAgICB0aGlzLmdlbmVyYXRlUmVwb3J0KCk7XFxuICAgICAgXFxuICAgICAgaWYgKHN1Y2Nlc3MpIHtcXG4gICAgICAgIHRoaXMubG9nKCfwn46JIERlcGxveW1lbnQgb3JjaGVzdHJhdGlvbiBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5IScpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB0aGlzLmxvZygn4p2MIERlcGxveW1lbnQgb3JjaGVzdHJhdGlvbiBmYWlsZWQnLCAnZXJyb3InKTtcXG4gICAgICB9XFxuICAgICAgXFxuICAgICAgcmV0dXJuIHN1Y2Nlc3M7XFxuICAgICAgXFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgICAgdGhpcy5sb2coYOKdjCBEZXBsb3ltZW50IG9yY2hlc3RyYXRpb24gZXJyb3I6ICR7ZXJyb3J9YCwgJ2Vycm9yJyk7XFxuICAgICAgdGhpcy5nZW5lcmF0ZVJlcG9ydCgpO1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vLyBDTEkgaW50ZXJmYWNlXFxuaWYgKHJlcXVpcmUubWFpbiA9PT0gbW9kdWxlKSB7XFxuICBjb25zdCBhcmdzID0gcHJvY2Vzcy5hcmd2LnNsaWNlKDIpO1xcbiAgXFxuICBjb25zdCBjb25maWc6IERlcGxveW1lbnRDb25maWcgPSB7XFxuICAgIGVudmlyb25tZW50OiAoYXJncy5maW5kKGFyZyA9PiBhcmcuc3RhcnRzV2l0aCgnLS1lbnY9JykpPy5zcGxpdCgnPScpWzFdIGFzIGFueSkgfHwgJ2RldicsXFxuICAgIHJlZ2lvbjogYXJncy5maW5kKGFyZyA9PiBhcmcuc3RhcnRzV2l0aCgnLS1yZWdpb249JykpPy5zcGxpdCgnPScpWzFdIHx8ICdldS13ZXN0LTEnLFxcbiAgICBzdGFja3M6IGFyZ3MuZmlsdGVyKGFyZyA9PiAhYXJnLnN0YXJ0c1dpdGgoJy0tJykgJiYgYXJnICE9PSAnaW1wb3J0JyksXFxuICAgIHZhbGlkYXRlQmVmb3JlOiAhYXJncy5pbmNsdWRlcygnLS1uby12YWxpZGF0ZScpLFxcbiAgICBob3Rzd2FwOiBhcmdzLmluY2x1ZGVzKCctLWhvdHN3YXAnKSxcXG4gICAgcmVxdWlyZUFwcHJvdmFsOiAhYXJncy5pbmNsdWRlcygnLS1uby1hcHByb3ZhbCcpLFxcbiAgICBpbXBvcnRNb2RlOiBhcmdzLmluY2x1ZGVzKCdpbXBvcnQnKSxcXG4gICAgZHJ5UnVuOiBhcmdzLmluY2x1ZGVzKCctLWRyeS1ydW4nKSxcXG4gIH07XFxuICBcXG4gIGlmIChhcmdzLmluY2x1ZGVzKCctLWhlbHAnKSB8fCBhcmdzLmluY2x1ZGVzKCctaCcpKSB7XFxuICAgIGNvbnNvbGUubG9nKGBcXG5UcmluaXR5IE1hc3RlciBEZXBsb3ltZW50IFNjcmlwdFxcblxcblVzYWdlOlxcbiAgbnB4IHRzLW5vZGUgZGVwbG95LW1hc3Rlci50cyBbb3B0aW9uc10gW3N0YWNrLW5hbWVzLi4uXVxcbiAgbnB4IHRzLW5vZGUgZGVwbG95LW1hc3Rlci50cyBpbXBvcnQgW29wdGlvbnNdIFtzdGFjay1uYW1lcy4uLl1cXG5cXG5PcHRpb25zOlxcbiAgLS1lbnY9PGVudj4gICAgICAgICAgRW52aXJvbm1lbnQgKGRldnxzdGFnaW5nfHByb2R1Y3Rpb24pIFtkZWZhdWx0OiBkZXZdXFxuICAtLXJlZ2lvbj08cmVnaW9uPiAgICBBV1MgcmVnaW9uIFtkZWZhdWx0OiBldS13ZXN0LTFdXFxuICAtLWhvdHN3YXAgICAgICAgICAgIEVuYWJsZSBDREsgaG90c3dhcCBmb3IgZmFzdGVyIGRlcGxveW1lbnRzXFxuICAtLW5vLWFwcHJvdmFsICAgICAgIFNraXAgZGVwbG95bWVudCBhcHByb3ZhbCBwcm9tcHRzXFxuICAtLW5vLXZhbGlkYXRlICAgICAgIFNraXAgcHJlLWRlcGxveW1lbnQgdmFsaWRhdGlvblxcbiAgLS1kcnktcnVuICAgICAgICAgICBTaG93IHdoYXQgd291bGQgYmUgZGVwbG95ZWQgd2l0aG91dCBleGVjdXRpbmdcXG4gIC0taGVscCwgLWggICAgICAgICAgU2hvdyB0aGlzIGhlbHAgbWVzc2FnZVxcblxcbkV4YW1wbGVzOlxcbiAgIyBEZXBsb3kgYWxsIHN0YWNrc1xcbiAgbnB4IHRzLW5vZGUgZGVwbG95LW1hc3Rlci50c1xcbiAgXFxuICAjIERlcGxveSBzcGVjaWZpYyBzdGFja3NcXG4gIG5weCB0cy1ub2RlIGRlcGxveS1tYXN0ZXIudHMgVHJpbml0eURhdGFiYXNlU3RhY2sgVHJpbml0eUxhbWJkYVN0YWNrXFxuICBcXG4gICMgSW1wb3J0IGV4aXN0aW5nIHJlc291cmNlc1xcbiAgbnB4IHRzLW5vZGUgZGVwbG95LW1hc3Rlci50cyBpbXBvcnQgVHJpbml0eURhdGFiYXNlU3RhY2tcXG4gIFxcbiAgIyBQcm9kdWN0aW9uIGRlcGxveW1lbnQgd2l0aCB2YWxpZGF0aW9uXFxuICBucHggdHMtbm9kZSBkZXBsb3ktbWFzdGVyLnRzIC0tZW52PXByb2R1Y3Rpb24gLS1yZWdpb249ZXUtd2VzdC0xXFxuICBcXG4gICMgRmFzdCBkZXZlbG9wbWVudCBkZXBsb3ltZW50XFxuICBucHggdHMtbm9kZSBkZXBsb3ktbWFzdGVyLnRzIC0taG90c3dhcCAtLW5vLWFwcHJvdmFsIFRyaW5pdHlMYW1iZGFTdGFja1xcbmApO1xcbiAgICBwcm9jZXNzLmV4aXQoMCk7XFxuICB9XFxuICBcXG4gIGNvbnN0IG1hbmFnZXIgPSBuZXcgVHJpbml0eURlcGxveW1lbnRNYW5hZ2VyKGNvbmZpZyk7XFxuICBtYW5hZ2VyLmV4ZWN1dGUoKS50aGVuKHN1Y2Nlc3MgPT4ge1xcbiAgICBwcm9jZXNzLmV4aXQoc3VjY2VzcyA/IDAgOiAxKTtcXG4gIH0pLmNhdGNoKGVycm9yID0+IHtcXG4gICAgY29uc29sZS5lcnJvcign4p2MIERlcGxveW1lbnQgZmFpbGVkOicsIGVycm9yKTtcXG4gICAgcHJvY2Vzcy5leGl0KDEpO1xcbiAgfSk7XFxufVxcblxcbmV4cG9ydCB7IFRyaW5pdHlEZXBsb3ltZW50TWFuYWdlciwgRGVwbG95bWVudENvbmZpZyB9O1xcblwiIl19