/**
 * Property-Based Tests for ResilientJSONParser
 * 
 * These tests validate the correctness properties defined in the design document
 * using fast-check for property-based testing.
 */

const fc = require('fast-check');
const { ResilientJSONParser } = require('../utils/jsonParser');

describe('ResilientJSONParser Property-Based Tests', () => {
    let parser;

    beforeEach(() => {
        parser = new ResilientJSONParser();
    });

    /**
     * Property 1: Schema Invariance
     * **Validates: Requirements 1.1, 1.2, 1.3**
     * 
     * For any string output generated by the LLM (simulated), the system MUST 
     * return a valid LLMResponse object or a safe Fallback object. 
     * It must never throw an unhandled syntax error.
     */
    describe('Property 1: Schema Invariance', () => {
        test('should always return valid LLMResponse for any string input', () => {
            fc.assert(
                fc.property(fc.string(), (randomString) => {
                    const result = parser.parse(randomString);
                    
                    // Must always return an object
                    expect(result).toBeDefined();
                    expect(typeof result).toBe('object');
                    expect(result).not.toBeNull();
                    
                    // Must have valid intent
                    expect(result).toHaveProperty('intent');
                    expect(['cinema', 'other']).toContain(result.intent);
                    
                    // Structure validation based on intent
                    if (result.intent === 'cinema') {
                        expect(result).toHaveProperty('titles');
                        expect(Array.isArray(result.titles)).toBe(true);
                        result.titles.forEach(title => {
                            expect(typeof title).toBe('string');
                        });
                    }
                    
                    if (result.intent === 'other') {
                        expect(result).toHaveProperty('reply');
                        expect(typeof result.reply).toBe('string');
                    }
                }),
                { numRuns: 100 }
            );
        });

        test('should never throw unhandled syntax errors', () => {
            fc.assert(
                fc.property(fc.string(), (randomString) => {
                    // This should never throw an exception
                    expect(() => {
                        parser.parse(randomString);
                    }).not.toThrow();
                }),
                { numRuns: 100 }
            );
        });
    });

    /**
     * Test malformed JSON scenarios specifically
     */
    describe('Malformed JSON Handling', () => {
        test('should handle JSON with missing closing braces', () => {
            const malformedInputs = [
                '{"intent": "cinema", "titles": ["Movie 1"',
                '{"intent": "other", "reply": "Hello"',
                '{"intent": "cinema"',
                '{"intent":'
            ];

            malformedInputs.forEach(input => {
                const result = parser.parse(input);
                expect(result).toBeDefined();
                expect(['cinema', 'other']).toContain(result.intent);
            });
        });

        test('should handle JSON with extra text before and after', () => {
            const chattyInputs = [
                'Here is my response: {"intent": "cinema", "titles": ["Movie 1"]} Hope this helps!',
                'Let me think... {"intent": "other", "reply": "Sorry, I only know about movies"} That\'s my answer.',
                'Response: {"intent": "cinema", "titles": ["The Matrix", "Inception"]}',
                'Well, {"intent": "other", "reply": "Cari単o, yo de eso no entiendo"} you know.'
            ];

            chattyInputs.forEach(input => {
                const result = parser.parse(input);
                expect(result).toBeDefined();
                expect(['cinema', 'other']).toContain(result.intent);
            });
        });

        test('should handle completely invalid JSON', () => {
            const invalidInputs = [
                'This is not JSON at all',
                '{"invalid": json}',
                '{broken json structure',
                'null',
                'undefined',
                '',
                '   ',
                '{"intent": "invalid_intent"}',
                '{"titles": ["movie"] }' // missing intent
            ];

            invalidInputs.forEach(input => {
                const result = parser.parse(input);
                expect(result).toBeDefined();
                expect(result.intent).toBe('other'); // Should fallback to 'other'
                expect(result.reply).toContain('cari単o'); // Should be in "La Trini" persona
            });
        });
    });

    /**
     * Test valid JSON scenarios
     */
    describe('Valid JSON Handling', () => {
        test('should correctly parse valid cinema responses', () => {
            const validCinemaInputs = [
                '{"intent": "cinema", "titles": ["The Matrix"]}',
                '{"intent": "cinema", "titles": ["Movie 1", "Movie 2", "Movie 3"]}',
                '{"intent": "cinema", "titles": []}'
            ];

            validCinemaInputs.forEach(input => {
                const result = parser.parse(input);
                expect(result.intent).toBe('cinema');
                expect(Array.isArray(result.titles)).toBe(true);
            });
        });

        test('should correctly parse valid other responses', () => {
            const validOtherInputs = [
                '{"intent": "other", "reply": "I only know about movies"}',
                '{"intent": "other", "reply": "Cari単o, yo de eso no entiendo"}',
                '{"intent": "other", "reply": ""}'
            ];

            validOtherInputs.forEach(input => {
                const result = parser.parse(input);
                expect(result.intent).toBe('other');
                expect(typeof result.reply).toBe('string');
            });
        });
    });

    /**
     * Test fallback response consistency
     */
    describe('Fallback Response Structure', () => {
        test('should return consistent fallback response structure', () => {
            const fallbackResponse = parser.getFallbackResponse();
            
            expect(fallbackResponse).toBeDefined();
            expect(fallbackResponse.intent).toBe('other');
            expect(typeof fallbackResponse.reply).toBe('string');
            expect(fallbackResponse.reply).toContain('cari単o');
        });

        test('should increment fallback count when using fallback', () => {
            parser.resetStats();
            
            // Parse invalid input to trigger fallback
            parser.parse('invalid json');
            
            const stats = parser.getStats();
            expect(stats.fallbackCount).toBe(1);
            expect(stats.parseAttempts).toBe(1);
        });
    });

    /**
     * Test parsing statistics
     */
    describe('Parsing Statistics', () => {
        test('should track parsing attempts correctly', () => {
            parser.resetStats();
            
            parser.parse('{"intent": "cinema", "titles": ["Movie"]}'); // Valid
            parser.parse('invalid'); // Invalid
            parser.parse('{"intent": "other", "reply": "Hello"}'); // Valid
            
            const stats = parser.getStats();
            expect(stats.parseAttempts).toBe(3);
            expect(stats.fallbackCount).toBe(1);
        });

        test('should calculate success rate correctly', () => {
            parser.resetStats();
            
            // 2 successful, 1 fallback
            parser.parse('{"intent": "cinema", "titles": ["Movie"]}');
            parser.parse('{"intent": "other", "reply": "Hello"}');
            parser.parse('invalid');
            
            const stats = parser.getStats();
            expect(stats.successRate).toBe('66.67%');
        });
    });

    /**
     * Edge cases and boundary conditions
     */
    describe('Edge Cases', () => {
        test('should handle null and undefined inputs', () => {
            expect(() => parser.parse(null)).not.toThrow();
            expect(() => parser.parse(undefined)).not.toThrow();
            
            const nullResult = parser.parse(null);
            const undefinedResult = parser.parse(undefined);
            
            expect(nullResult.intent).toBe('other');
            expect(undefinedResult.intent).toBe('other');
        });

        test('should handle non-string inputs', () => {
            const nonStringInputs = [123, true, false, {}, []];
            
            nonStringInputs.forEach(input => {
                expect(() => parser.parse(input)).not.toThrow();
                const result = parser.parse(input);
                expect(result.intent).toBe('other');
            });
        });

        test('should handle very large strings', () => {
            const largeString = 'x'.repeat(10000) + '{"intent": "cinema", "titles": ["Movie"]}' + 'y'.repeat(10000);
            
            expect(() => parser.parse(largeString)).not.toThrow();
            const result = parser.parse(largeString);
            expect(result).toBeDefined();
        });

        test('should handle nested JSON structures', () => {
            const nestedJson = '{"intent": "cinema", "titles": ["Movie"], "extra": {"nested": "value"}}';
            
            const result = parser.parse(nestedJson);
            expect(result.intent).toBe('cinema');
            expect(Array.isArray(result.titles)).toBe(true);
        });
    });
});