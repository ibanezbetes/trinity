/**\n * Property-Based Test: Data Model Round-Trip Consistency\n * Validates: Requirements 6.4 - Data Model Consistency\n * Property 9: Data model round-trip consistency\n * \n * This test ensures that all data models maintain consistency through\n * serialization/deserialization cycles, database operations, and API\n * transformations without data loss or corruption.\n */\n\nimport * as fc from 'fast-check';\nimport { \n  TrinityGenerators, \n  PropertyTestConfig, \n  PropertyTestPatterns,\n  TrinityValidators,\n  PropertyTestMocks\n} from './property-test-utils';\nimport { TrinityDatabase } from '../src/shared/database';\nimport { TrinityConfig } from '../src/shared/config';\nimport { TrinityLogger } from '../src/shared/logger';\n\n// Mock AWS SDK and dependencies\njest.mock('aws-sdk');\njest.mock('../src/shared/config');\njest.mock('../src/shared/database');\njest.mock('../src/shared/logger');\n\ndescribe('Property 9: Data Model Round-Trip Consistency', () => {\n  let mockDatabase: jest.Mocked<TrinityDatabase>;\n  let mockConfig: jest.Mocked<TrinityConfig>;\n  let mockLogger: jest.Mocked<TrinityLogger>;\n\n  beforeEach(() => {\n    // Reset all mocks\n    jest.clearAllMocks();\n    \n    // Setup mock dependencies\n    mockDatabase = PropertyTestMocks.createMockDynamoDB() as any;\n    mockConfig = PropertyTestMocks.createMockConfig() as any;\n    mockLogger = PropertyTestMocks.createMockLogger() as any;\n  });\n\n  /**\n   * Property 9.1: Movie data model round-trip consistency\n   */\n  test('Property 9.1: Movie data model round-trip consistency', () => {\n    fc.assert(\n      PropertyTestPatterns.roundTrip(\n        TrinityGenerators.movie(),\n        // Serialize: Convert to DynamoDB format\n        (movie) => {\n          const dynamoItem = {\n            movieId: movie.id.toString(),\n            title: movie.title,\n            overview: movie.overview,\n            releaseDate: movie.release_date,\n            genreIds: movie.genre_ids,\n            voteAverage: movie.vote_average,\n            popularity: movie.popularity,\n            cachedAt: Math.floor(Date.now() / 1000),\n            ttl: Math.floor(Date.now() / 1000) + 86400,\n          };\n          return JSON.stringify(dynamoItem);\n        },\n        // Deserialize: Convert back to movie format\n        (serialized) => {\n          const dynamoItem = JSON.parse(serialized);\n          return {\n            id: parseInt(dynamoItem.movieId),\n            title: dynamoItem.title,\n            overview: dynamoItem.overview,\n            release_date: dynamoItem.releaseDate,\n            genre_ids: dynamoItem.genreIds,\n            vote_average: dynamoItem.voteAverage,\n            popularity: dynamoItem.popularity,\n          };\n        },\n        // Custom equality check for floating point numbers\n        (original, roundTrip) => {\n          return (\n            original.id === roundTrip.id &&\n            original.title === roundTrip.title &&\n            original.overview === roundTrip.overview &&\n            original.release_date === roundTrip.release_date &&\n            JSON.stringify(original.genre_ids) === JSON.stringify(roundTrip.genre_ids) &&\n            Math.abs(original.vote_average - roundTrip.vote_average) < 0.001 &&\n            Math.abs(original.popularity - roundTrip.popularity) < 0.001\n          );\n        }\n      ),\n      PropertyTestConfig.standard()\n    );\n  });\n\n  /**\n   * Property 9.2: Vote data model round-trip consistency\n   */\n  test('Property 9.2: Vote data model round-trip consistency', () => {\n    fc.assert(\n      PropertyTestPatterns.roundTrip(\n        TrinityGenerators.vote(),\n        // Serialize: Convert to DynamoDB format\n        (vote) => {\n          const dynamoItem = {\n            roomId: vote.roomId,\n            movieId: vote.movieId,\n            userId: vote.userId,\n            vote: vote.vote,\n            timestamp: vote.timestamp,\n            createdAt: new Date().toISOString(),\n          };\n          return JSON.stringify(dynamoItem);\n        },\n        // Deserialize: Convert back to vote format\n        (serialized) => {\n          const dynamoItem = JSON.parse(serialized);\n          return {\n            roomId: dynamoItem.roomId,\n            movieId: dynamoItem.movieId,\n            userId: dynamoItem.userId,\n            vote: dynamoItem.vote,\n            timestamp: dynamoItem.timestamp,\n          };\n        }\n      ),\n      PropertyTestConfig.standard()\n    );\n  });\n\n  /**\n   * Property 9.3: Room configuration round-trip consistency\n   */\n  test('Property 9.3: Room configuration round-trip consistency', () => {\n    fc.assert(\n      PropertyTestPatterns.roundTrip(\n        TrinityGenerators.roomConfig(),\n        // Serialize: Convert to DynamoDB format\n        (config) => {\n          const dynamoItem = {\n            roomId: config.roomId,\n            capacity: config.capacity,\n            genreIds: config.genreIds,\n            contentType: config.contentType,\n            minYear: config.minYear,\n            maxYear: config.maxYear,\n            minRating: config.minRating,\n            createdAt: new Date().toISOString(),\n            status: 'ACTIVE',\n          };\n          return JSON.stringify(dynamoItem);\n        },\n        // Deserialize: Convert back to config format\n        (serialized) => {\n          const dynamoItem = JSON.parse(serialized);\n          return {\n            roomId: dynamoItem.roomId,\n            capacity: dynamoItem.capacity,\n            genreIds: dynamoItem.genreIds,\n            contentType: dynamoItem.contentType,\n            minYear: dynamoItem.minYear,\n            maxYear: dynamoItem.maxYear,\n            minRating: dynamoItem.minRating,\n          };\n        }\n      ),\n      PropertyTestConfig.standard()\n    );\n  });\n\n  /**\n   * Property 9.4: GraphQL API transformation consistency\n   */\n  test('Property 9.4: GraphQL API transformation consistency', () => {\n    fc.assert(\n      fc.property(\n        TrinityGenerators.movie(),\n        (movie) => {\n          // Transform to GraphQL response format\n          const graphqlResponse = {\n            id: movie.id.toString(),\n            title: movie.title,\n            overview: movie.overview,\n            releaseDate: movie.release_date,\n            genres: movie.genre_ids.map(id => ({ id, name: `Genre ${id}` })),\n            rating: movie.vote_average,\n            popularity: movie.popularity,\n          };\n\n          // Transform back to internal format\n          const backToInternal = {\n            id: parseInt(graphqlResponse.id),\n            title: graphqlResponse.title,\n            overview: graphqlResponse.overview,\n            release_date: graphqlResponse.releaseDate,\n            genre_ids: graphqlResponse.genres.map(g => g.id),\n            vote_average: graphqlResponse.rating,\n            popularity: graphqlResponse.popularity,\n          };\n\n          // Verify round-trip consistency\n          return (\n            movie.id === backToInternal.id &&\n            movie.title === backToInternal.title &&\n            movie.overview === backToInternal.overview &&\n            movie.release_date === backToInternal.release_date &&\n            JSON.stringify(movie.genre_ids.sort()) === JSON.stringify(backToInternal.genre_ids.sort()) &&\n            Math.abs(movie.vote_average - backToInternal.vote_average) < 0.001 &&\n            Math.abs(movie.popularity - backToInternal.popularity) < 0.001\n          );\n        }\n      ),\n      PropertyTestConfig.standard()\n    );\n  });\n\n  /**\n   * Property 9.5: DynamoDB attribute type consistency\n   */\n  test('Property 9.5: DynamoDB attribute type consistency', () => {\n    fc.assert(\n      fc.property(\n        fc.record({\n          stringValue: fc.string(),\n          numberValue: fc.float({ noNaN: true, noDefaultInfinity: true }),\n          booleanValue: fc.boolean(),\n          arrayValue: fc.array(fc.string(), { maxLength: 10 }),\n          objectValue: fc.record({\n            nestedString: fc.string(),\n            nestedNumber: fc.integer(),\n          }),\n        }),\n        (testData) => {\n          // Simulate DynamoDB marshalling/unmarshalling\n          const marshalled = {\n            stringValue: { S: testData.stringValue },\n            numberValue: { N: testData.numberValue.toString() },\n            booleanValue: { BOOL: testData.booleanValue },\n            arrayValue: { SS: testData.arrayValue },\n            objectValue: { \n              M: {\n                nestedString: { S: testData.objectValue.nestedString },\n                nestedNumber: { N: testData.objectValue.nestedNumber.toString() },\n              }\n            },\n          };\n\n          // Unmarshall back to original format\n          const unmarshalled = {\n            stringValue: marshalled.stringValue.S,\n            numberValue: parseFloat(marshalled.numberValue.N),\n            booleanValue: marshalled.booleanValue.BOOL,\n            arrayValue: marshalled.arrayValue.SS,\n            objectValue: {\n              nestedString: marshalled.objectValue.M.nestedString.S,\n              nestedNumber: parseInt(marshalled.objectValue.M.nestedNumber.N),\n            },\n          };\n\n          // Verify type consistency\n          return (\n            testData.stringValue === unmarshalled.stringValue &&\n            Math.abs(testData.numberValue - unmarshalled.numberValue) < 0.001 &&\n            testData.booleanValue === unmarshalled.booleanValue &&\n            JSON.stringify(testData.arrayValue) === JSON.stringify(unmarshalled.arrayValue) &&\n            testData.objectValue.nestedString === unmarshalled.objectValue.nestedString &&\n            testData.objectValue.nestedNumber === unmarshalled.objectValue.nestedNumber\n          );\n        }\n      ),\n      PropertyTestConfig.standard()\n    );\n  });\n\n  /**\n   * Property 9.6: Cache entry serialization consistency\n   */\n  test('Property 9.6: Cache entry serialization consistency', () => {\n    fc.assert(\n      fc.property(\n        fc.record({\n          movieId: TrinityGenerators.movieId().map(id => id.toString()),\n          movieData: TrinityGenerators.movie(),\n          cachedAt: TrinityGenerators.timestamp(),\n          ttl: TrinityGenerators.ttl(),\n        }),\n        (cacheEntry) => {\n          // Serialize cache entry for storage\n          const serialized = {\n            movieId: cacheEntry.movieId,\n            data: JSON.stringify(cacheEntry.movieData),\n            cachedAt: cacheEntry.cachedAt,\n            ttl: cacheEntry.ttl,\n            version: '1.0',\n          };\n\n          // Deserialize cache entry from storage\n          const deserialized = {\n            movieId: serialized.movieId,\n            movieData: JSON.parse(serialized.data),\n            cachedAt: serialized.cachedAt,\n            ttl: serialized.ttl,\n          };\n\n          // Verify consistency\n          return (\n            cacheEntry.movieId === deserialized.movieId &&\n            cacheEntry.cachedAt === deserialized.cachedAt &&\n            cacheEntry.ttl === deserialized.ttl &&\n            TrinityValidators.isValidMovie(deserialized.movieData) &&\n            cacheEntry.movieData.id === deserialized.movieData.id &&\n            cacheEntry.movieData.title === deserialized.movieData.title\n          );\n        }\n      ),\n      PropertyTestConfig.standard()\n    );\n  });\n\n  /**\n   * Property 9.7: Database operation idempotency\n   */\n  test('Property 9.7: Database operation idempotency', () => {\n    fc.assert(\n      fc.asyncProperty(\n        TrinityGenerators.movie(),\n        async (movie) => {\n          const movieId = movie.id.toString();\n          let putCallCount = 0;\n          let getCallCount = 0;\n\n          // Mock database operations\n          mockDatabase.putItem.mockImplementation(async (params) => {\n            putCallCount++;\n            return {};\n          });\n\n          mockDatabase.getItem.mockImplementation(async (params) => {\n            getCallCount++;\n            return {\n              Item: {\n                movieId,\n                title: movie.title,\n                overview: movie.overview,\n                data: JSON.stringify(movie),\n                cachedAt: Math.floor(Date.now() / 1000),\n                ttl: Math.floor(Date.now() / 1000) + 86400,\n              }\n            };\n          });\n\n          // Simulate caching the same movie multiple times (should be idempotent)\n          const cacheOperations = Array(3).fill(null).map(() => \n            mockDatabase.putItem({\n              TableName: 'trinity-movies-cache-dev',\n              Item: {\n                movieId,\n                title: movie.title,\n                overview: movie.overview,\n                data: JSON.stringify(movie),\n                cachedAt: Math.floor(Date.now() / 1000),\n                ttl: Math.floor(Date.now() / 1000) + 86400,\n              }\n            })\n          );\n\n          await Promise.all(cacheOperations);\n\n          // Verify operations were called\n          expect(putCallCount).toBe(3);\n\n          // Simulate reading the cached movie multiple times\n          const readOperations = Array(3).fill(null).map(() => \n            mockDatabase.getItem({\n              TableName: 'trinity-movies-cache-dev',\n              Key: { movieId }\n            })\n          );\n\n          const results = await Promise.all(readOperations);\n\n          // Verify all reads return consistent data\n          expect(getCallCount).toBe(3);\n          expect(results.every(result => \n            result.Item?.movieId === movieId &&\n            result.Item?.title === movie.title\n          )).toBe(true);\n\n          return true;\n        }\n      ),\n      PropertyTestConfig.fast()\n    );\n  });\n\n  /**\n   * Property 9.8: JSON serialization edge cases\n   */\n  test('Property 9.8: JSON serialization edge cases', () => {\n    fc.assert(\n      fc.property(\n        fc.record({\n          // Test various edge cases in JSON serialization\n          emptyString: fc.constant(''),\n          unicodeString: fc.fullUnicodeString({ maxLength: 50 }),\n          specialNumbers: fc.oneof(\n            fc.constant(0),\n            fc.constant(-0),\n            fc.constant(Number.MAX_SAFE_INTEGER),\n            fc.constant(Number.MIN_SAFE_INTEGER),\n            fc.float({ min: -1000, max: 1000, noNaN: true, noDefaultInfinity: true })\n          ),\n          emptyArray: fc.constant([]),\n          emptyObject: fc.constant({}),\n          nestedStructure: fc.record({\n            level1: fc.record({\n              level2: fc.record({\n                value: fc.string()\n              })\n            })\n          }),\n        }),\n        (testData) => {\n          try {\n            // Serialize to JSON\n            const serialized = JSON.stringify(testData);\n            \n            // Deserialize from JSON\n            const deserialized = JSON.parse(serialized);\n            \n            // Verify round-trip consistency\n            return (\n              testData.emptyString === deserialized.emptyString &&\n              testData.unicodeString === deserialized.unicodeString &&\n              Math.abs(testData.specialNumbers - deserialized.specialNumbers) < 0.001 &&\n              JSON.stringify(testData.emptyArray) === JSON.stringify(deserialized.emptyArray) &&\n              JSON.stringify(testData.emptyObject) === JSON.stringify(deserialized.emptyObject) &&\n              testData.nestedStructure.level1.level2.value === deserialized.nestedStructure.level1.level2.value\n            );\n          } catch (error) {\n            // JSON serialization should not fail for valid data\n            return false;\n          }\n        }\n      ),\n      PropertyTestConfig.standard()\n    );\n  });\n\n  /**\n   * Property 9.9: Timestamp precision consistency\n   */\n  test('Property 9.9: Timestamp precision consistency', () => {\n    fc.assert(\n      fc.property(\n        fc.record({\n          jsTimestamp: fc.integer({ min: 1600000000000, max: 2000000000000 }), // JS timestamp (ms)\n          unixTimestamp: fc.integer({ min: 1600000000, max: 2000000000 }), // Unix timestamp (s)\n          isoString: fc.date({ min: new Date('2020-01-01'), max: new Date('2030-01-01') })\n            .map(d => d.toISOString()),\n        }),\n        (timestamps) => {\n          // Convert between different timestamp formats\n          const jsToUnix = Math.floor(timestamps.jsTimestamp / 1000);\n          const unixToJs = timestamps.unixTimestamp * 1000;\n          const isoToJs = new Date(timestamps.isoString).getTime();\n          const jsToIso = new Date(timestamps.jsTimestamp).toISOString();\n          \n          // Verify conversions maintain reasonable precision\n          const jsToUnixToJs = jsToUnix * 1000;\n          const unixToJsToUnix = Math.floor(unixToJs / 1000);\n          \n          return (\n            // JS to Unix conversion should be within 1 second precision\n            Math.abs(timestamps.jsTimestamp - jsToUnixToJs) < 1000 &&\n            // Unix to JS conversion should be exact\n            timestamps.unixTimestamp === unixToJsToUnix &&\n            // ISO string conversions should be consistent\n            typeof jsToIso === 'string' &&\n            jsToIso.includes('T') &&\n            jsToIso.includes('Z') &&\n            !isNaN(isoToJs)\n          );\n        }\n      ),\n      PropertyTestConfig.standard()\n    );\n  });\n\n  /**\n   * Property 9.10: Data validation consistency\n   */\n  test('Property 9.10: Data validation consistency', () => {\n    fc.assert(\n      fc.property(\n        fc.oneof(\n          TrinityGenerators.movie(),\n          TrinityGenerators.vote(),\n          TrinityGenerators.roomConfig()\n        ),\n        (data) => {\n          // Validate original data\n          let isValidOriginal = false;\n          if ('id' in data && 'title' in data) {\n            isValidOriginal = TrinityValidators.isValidMovie(data);\n          } else if ('vote' in data && 'userId' in data) {\n            isValidOriginal = TrinityValidators.isValidVote(data);\n          } else if ('capacity' in data && 'genreIds' in data) {\n            isValidOriginal = TrinityValidators.isValidRoomConfig(data);\n          }\n\n          // Serialize and deserialize\n          const serialized = JSON.stringify(data);\n          const deserialized = JSON.parse(serialized);\n\n          // Validate deserialized data\n          let isValidDeserialized = false;\n          if ('id' in deserialized && 'title' in deserialized) {\n            isValidDeserialized = TrinityValidators.isValidMovie(deserialized);\n          } else if ('vote' in deserialized && 'userId' in deserialized) {\n            isValidDeserialized = TrinityValidators.isValidVote(deserialized);\n          } else if ('capacity' in deserialized && 'genreIds' in deserialized) {\n            isValidDeserialized = TrinityValidators.isValidRoomConfig(deserialized);\n          }\n\n          // Validation should be consistent across serialization\n          return isValidOriginal === isValidDeserialized;\n        }\n      ),\n      PropertyTestConfig.standard()\n    );\n  });\n\n  /**\n   * Integration test: Complete data lifecycle consistency\n   */\n  test('Integration: Complete data lifecycle maintains consistency', () => {\n    fc.assert(\n      fc.asyncProperty(\n        fc.array(TrinityGenerators.movie(), { minLength: 5, maxLength: 15 }),\n        async (movies) => {\n          const dataStore: Record<string, any> = {};\n          let operationLog: string[] = [];\n\n          // Mock complete data lifecycle\n          mockDatabase.putItem.mockImplementation(async (params) => {\n            const key = params.Item.movieId || params.Item.roomId || params.Item.userId;\n            dataStore[key] = JSON.parse(JSON.stringify(params.Item)); // Deep copy\n            operationLog.push(`PUT:${key}`);\n            return {};\n          });\n\n          mockDatabase.getItem.mockImplementation(async (params) => {\n            const key = params.Key.movieId || params.Key.roomId || params.Key.userId;\n            const item = dataStore[key];\n            operationLog.push(`GET:${key}`);\n            return { Item: item ? JSON.parse(JSON.stringify(item)) : null };\n          });\n\n          mockDatabase.updateItem.mockImplementation(async (params) => {\n            const key = params.Key.movieId || params.Key.roomId || params.Key.userId;\n            if (dataStore[key]) {\n              // Simulate update operation\n              dataStore[key] = { ...dataStore[key], updatedAt: Date.now() };\n              operationLog.push(`UPDATE:${key}`);\n            }\n            return { Attributes: dataStore[key] };\n          });\n\n          // Execute complete lifecycle for each movie\n          for (const movie of movies) {\n            const movieId = movie.id.toString();\n            \n            // 1. Store movie data\n            await mockDatabase.putItem({\n              TableName: 'trinity-movies-cache-dev',\n              Item: {\n                movieId,\n                title: movie.title,\n                overview: movie.overview,\n                data: JSON.stringify(movie),\n                cachedAt: Math.floor(Date.now() / 1000),\n                ttl: Math.floor(Date.now() / 1000) + 86400,\n              }\n            });\n            \n            // 2. Retrieve movie data\n            const retrieved = await mockDatabase.getItem({\n              TableName: 'trinity-movies-cache-dev',\n              Key: { movieId }\n            });\n            \n            // 3. Verify data consistency\n            expect(retrieved.Item).toBeDefined();\n            expect(retrieved.Item?.movieId).toBe(movieId);\n            expect(retrieved.Item?.title).toBe(movie.title);\n            \n            // 4. Parse stored movie data\n            const storedMovieData = JSON.parse(retrieved.Item?.data || '{}');\n            expect(TrinityValidators.isValidMovie(storedMovieData)).toBe(true);\n            expect(storedMovieData.id).toBe(movie.id);\n            expect(storedMovieData.title).toBe(movie.title);\n            \n            // 5. Update movie data\n            await mockDatabase.updateItem({\n              TableName: 'trinity-movies-cache-dev',\n              Key: { movieId },\n              UpdateExpression: 'SET #ua = :ua',\n              ExpressionAttributeNames: { '#ua': 'updatedAt' },\n              ExpressionAttributeValues: { ':ua': Date.now() }\n            });\n            \n            // 6. Verify update consistency\n            const updated = await mockDatabase.getItem({\n              TableName: 'trinity-movies-cache-dev',\n              Key: { movieId }\n            });\n            \n            expect(updated.Item?.updatedAt).toBeDefined();\n            expect(updated.Item?.title).toBe(movie.title); // Original data preserved\n          }\n\n          // Verify operation log consistency\n          expect(operationLog.length).toBe(movies.length * 4); // PUT, GET, UPDATE, GET for each movie\n          \n          // Verify all data is still valid\n          for (const [key, item] of Object.entries(dataStore)) {\n            expect(item.movieId).toBe(key);\n            expect(item.title).toBeDefined();\n            expect(item.data).toBeDefined();\n            \n            const movieData = JSON.parse(item.data);\n            expect(TrinityValidators.isValidMovie(movieData)).toBe(true);\n          }\n\n          console.log(`âœ… Lifecycle test: ${movies.length} movies, ${operationLog.length} operations`);\n          return true;\n        }\n      ),\n      PropertyTestConfig.fast()\n    );\n  });\n});\n\n/**\n * Test utilities for data model validation\n */\nexport class DataModelTestUtils {\n  /**\n   * Generate test data that intentionally has edge cases\n   */\n  static generateEdgeCaseData() {\n    return fc.oneof(\n      // Empty/minimal values\n      fc.record({\n        id: fc.constant(1),\n        title: fc.constant('A'),\n        overview: fc.constant(''),\n        release_date: fc.constant('1900-01-01'),\n        genre_ids: fc.constant([1]),\n        vote_average: fc.constant(0),\n        popularity: fc.constant(0),\n      }),\n      // Maximum values\n      fc.record({\n        id: fc.constant(999999),\n        title: fc.constant('A'.repeat(100)),\n        overview: fc.constant('B'.repeat(500)),\n        release_date: fc.constant('2030-12-31'),\n        genre_ids: fc.constant([1, 2, 3, 4, 5]),\n        vote_average: fc.constant(10),\n        popularity: fc.constant(1000),\n      }),\n      // Unicode and special characters\n      fc.record({\n        id: fc.integer({ min: 1, max: 999999 }),\n        title: fc.constant('ðŸŽ¬ Movie Title with Ã©mojis & spÃ«cial chars'),\n        overview: fc.constant('Overview with unicode: ä½ å¥½ä¸–ç•Œ ðŸŒ'),\n        release_date: fc.date().map(d => d.toISOString().split('T')[0]),\n        genre_ids: TrinityGenerators.genreIds(),\n        vote_average: TrinityGenerators.voteAverage(),\n        popularity: TrinityGenerators.popularity(),\n      })\n    );\n  }\n\n  /**\n   * Validate that serialization preserves all required fields\n   */\n  static validateSerializationCompleteness<T extends Record<string, any>>(\n    original: T,\n    serialized: string,\n    deserialized: T,\n    requiredFields: (keyof T)[]\n  ): boolean {\n    // Check that serialization doesn't lose required fields\n    for (const field of requiredFields) {\n      if (!(field in deserialized)) {\n        return false;\n      }\n      \n      // Check that the field value is preserved (with type coercion tolerance)\n      const originalValue = original[field];\n      const deserializedValue = deserialized[field];\n      \n      if (typeof originalValue !== typeof deserializedValue) {\n        // Allow number/string coercion for IDs\n        if ((typeof originalValue === 'number' && typeof deserializedValue === 'string') ||\n            (typeof originalValue === 'string' && typeof deserializedValue === 'number')) {\n          if (originalValue.toString() !== deserializedValue.toString()) {\n            return false;\n          }\n        } else {\n          return false;\n        }\n      } else if (originalValue !== deserializedValue) {\n        // For objects and arrays, use deep comparison\n        if (JSON.stringify(originalValue) !== JSON.stringify(deserializedValue)) {\n          return false;\n        }\n      }\n    }\n    \n    return true;\n  }\n\n  /**\n   * Test data transformation pipeline\n   */\n  static testTransformationPipeline<T>(\n    input: T,\n    transformations: Array<(data: any) => any>,\n    validator: (data: any) => boolean\n  ): boolean {\n    let current = input;\n    \n    // Apply all transformations in sequence\n    for (const transform of transformations) {\n      try {\n        current = transform(current);\n        \n        // Validate at each step\n        if (!validator(current)) {\n          return false;\n        }\n      } catch (error) {\n        return false;\n      }\n    }\n    \n    return true;\n  }\n}"